{
  "url": "https://mau.fi/blog/megabridge-twilio",
  "markdown": "# Writing a Twilio bridge - Tulir Asokan\n*By Tulir Asokan*\n---\nIn this post, I'll go over all the steps necessary to build a Twilio bridge using the new bridgev2 module in mautrix-go. The whole bridge can be found at [github.com/mautrix/twilio](https://github.com/mautrix/twilio).\n## [Getting started with a new Go project](#getting-started-with-a-new-go-project)\nThe first step to make a new Go project is to create a new directory and run `go mod init <module path>`, where `<module path>` is the import path of your new module (for example, the GitHub repo). In addition to that, we'll want to add the mautrix-go and Twilio libraries as dependencies. Since bridgev2 is under active development, we'll ask for `@main` instead of the latest tag.\n|\n1\n2\n3\n |\n```\ngo mod init go.mau.fi/mautrix-twilio\ngo get maunium.net/go/mautrix@main\ngo get github.com/twilio/twilio-go\n```\n |\nWhen naming your bridge, please make up your own name and don't use `mautrix-*`.\n## [The connector itself](#the-connector-itself)\nThe next step is creating the network connector itself. The connector is effectively a library, so we'll put it in `pkg/connector/` and create a file called `connector.go`. Because this is a minimal example, that file will also be the only file in the connector package, but real connectors will probably want to split up the parts that come later into different files.\nInside the file, let's start by defining a struct called `TwilioConnector`. This struct is the main entrypoint to the connector. It is passed to the central bridge module and is used to initialize other things.\n|\n1\n2\n3\n4\n5\n6\n7\n8\n9\n |\n```\npackage connector\nimport (\n    \"maunium.net/go/mautrix/bridgev2\"\n)\ntype TwilioConnector struct {\n\tbr *bridgev2.Bridge\n}\n```\n |\nThen, add a line like this:\n|\n1\n |\n```\nvar _ bridgev2.NetworkConnector = (*TwilioConnector)(nil)\n```\n |\nThis is a conventional method of ensuring that a struct implements a specific interface. The line is creating a value of type `*TwilioConnector`, then assigning it to a variable of type `bridgev2.NetworkConnector`, which will only compile if the value implements the interface. The variable name is the blank identifier `_`, which means the value will be discarded after being evaluated.\nIf you're using a smart editor, it should complain that `*TwilioConnector` does not in fact implement `bridgev2.NetworkConnector`, and possibly even offer you a quick way to create stub methods to implement the interface.\n### [`Init`](#init)\nThe Init function is called when the bridge is initializing all types. It also gives you access to the bridge struct, which will need to be stored for later.\nThis function should not do any kind of IO or other complicated operations, it should just initialize the in-memory struct.\n|\n1\n2\n3\n |\n```\nfunc (tc *TwilioConnector) Init(bridge *bridgev2.Bridge) {\n\ttc.br = bridge\n}\n```\n |\n### [`Start`](#start)\nThe Start function is called slightly later in the startup. This can be used for bridge-wide IO operations, such as upgrading database schemas if the connector needs its own database tables.\nIn the case of Twilio, there's no need for special database tables, but we do need to register some routes, as receiving messages requires a webhook. Other networks that receive events via websockets/polling/etc. may not need to do anything at all here.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n |\n```\nfunc (tc *TwilioConnector) Start(ctx context.Context) error {\n\tserver, ok := tc.br.Matrix.(bridgev2.MatrixConnectorWithServer)\n\tif !ok {\n\t\treturn fmt.Errorf(\"matrix connector does not implement MatrixConnectorWithServer\")\n\t} else if server.GetPublicAddress() == \"\" {\n\t\treturn fmt.Errorf(\"public address of bridge not configured\")\n\t}\n\trouter := http.NewServeMux()\n\trouter.HandleFunc(\"POST /{loginID}/receive\", tc.ReceiveMessage)\n\tserver.GetRouter().Handle(\"/_twilio/\", exhttp.ApplyMiddleware(\n\t\trouter,\n\t\texhttp.StripPrefix(\"/_twilio\"),\n\t\thlog.NewHandler(tc.br.Log.With().Str(\"component\", \"twilio webhooks\").Logger()),\n\t\trequestlog.AccessLogger(requestlog.Options{TrustXForwardedFor: true}),\n\t))\n\treturn nil\n}\nfunc (tc *TwilioConnector) ReceiveMessage(w http.ResponseWriter, r *http.Request) {}\n```\n |\n**Update July 2025:** The gorilla/mux HTTP router in mautrix-go was replaced with the standard library. Subrouters/middlewares need to be applied slightly more manually now.\nWe'll come back to `ReceiveMessage` [later](#twilio--matrix).\n### [`GetCapabilities`](#getcapabilities)\nThe `GetCapabilities` function on the network connector is used to signal some bridge-wide capabilities, like disappearing message support. Twilio doesn't have any of the relevant features, so we'll just leave this empty.\n|\n1\n2\n3\n |\n```\nfunc (tc *TwilioConnector) GetCapabilities() *bridgev2.NetworkGeneralCapabilities {\n\treturn &bridgev2.NetworkGeneralCapabilities{}\n}\n```\n |\n### [`GetBridgeInfoVersion`](#getbridgeinfoversion)\nThis function was added in January 2025 along with the updates to the per-room `GetCapabilities` method on network clients (below, not the one right above).\nThe `GetBridgeInfoVersion` function on the network connector returns two integers, which are usually just hardcoded version numbers. When you modify the room capabilities, you should increment the second return value to tell mautrix-go to resend all `com.beeper.room_features` state events. Similarly, if you modify something that affects the `uk.half-shot.bridge` state event, increment the first return value.\n|\n1\n2\n3\n |\n```\nfunc (tc *TwilioConnector) GetBridgeInfoVersion() (info, capabilities int) {\n\treturn 1, 1\n}\n```\n |\n### [`GetName`](#getname)\nThe `GetName` function is used to customize the name of the bridge.\n-   `DisplayName` is a simple human-readable name for the network. It doesn't have any particular rules. It usually starts with a capital letter. This is used in lots of places.\n-   `NetworkURL` is the website associated with the network. This is used in the `protocol` section of `m.bridge` events.\n-   `NetworkIcon` is a `mxc://` URI which contains the logo of the network. This is used in the `protocol` section of `m.bridge` events, as well as in the avatar of the bridge bot user.\n-   `NetworkID` is a string that uniquely identifies the network. If there are multiple bridge implementations for the same network, they should use the same ID. This is conventionally all lowercase.\n-   `BeeperBridgeType` identifies the specific bridge implementation. The Go module import path is a good option for this to ensure uniqueness, but bridges used by Beeper use shorter types (e.g. the Go rewrite of the Discord bridge used `discordgo`).\n-   `DefaultPort` can optionally be set to change the default port when generating the example config. It is not required and will default to `8008` when unset. All mautrix bridges use ports defined in [mau.fi/ports](https://mau.fi/ports).\n-   `DefaultCommandPrefix` can optionally be set to change the default command prefix when generating the example config. It is not required and will default to `!` followed by the `NetworkID`.\n|\n 1 2 3 4 5 6 7 8 9\n10\n |\n```\nfunc (tc *TwilioConnector) GetName() bridgev2.BridgeName {\n\treturn bridgev2.BridgeName{\n\t\tDisplayName:      \"Twilio\",\n\t\tNetworkURL:       \"https://twilio.com\",\n\t\tNetworkIcon:      \"mxc://maunium.net/FYuKJHaCrSeSpvBJfHwgYylP\",\n\t\tNetworkID:        \"twilio\",\n\t\tBeeperBridgeType: \"go.mau.fi/mautrix-twilio\",\n\t\tDefaultPort:      29322,\n\t}\n}\n```\n |\n### [`GetConfig`](#getconfig)\nNetwork connectors can define their own config fields, which for normal bridges using `mxmain` will be in the `network:` section of the config.\nThe `GetConfig` function returns all data that is needed to provide the config.\n-   `example` is the example config.\n-   `data` is a pointer to the object where the config should be decoded to.\n-   `upgrader` is a helper to perform config upgrades.\nOn startup, the bridge will read the user's config file as well as the example config, then call the upgrader to copy values from the user's config into the example, and finally overwrite the user's config with the example. Users can disable the overwriting part if they don't like it, but the first two steps are done in any case. There are two benefits to this system:\n-   the bridge doesn't need to have any backwards-compatibility for the config outside the upgrader function. The upgrader can simply copy fields from old locations into new ones.\n-   the user can easily get an upgraded config without having to manually figure out which fields have changed.\nThe Twilio connector doesn't need any special fields, so we can just return nil values.\n|\n1\n2\n3\n |\n```\nfunc (tc *TwilioConnector) GetConfig() (example string, data any, upgrader configupgrade.Upgrader) {\n\treturn \"\", nil, configupgrade.NoopUpgrader\n}\n```\n |\nIf you did want config fields, the response would look something like this:\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n |\n```\ntype TwilioConnector struct {\n\t...\n\tConfig Config\n}\ntype Config struct {\n\tMyFancyField string `yaml:\"my_fancy_field\"`\n}\n//go:embed example-config.yaml\nvar ExampleConfig string\nfunc upgradeConfig(helper configupgrade.Helper) {\n\thelper.Copy(configupgrade.Str, \"my_fancy_field\")\n}\nfunc (tc *TwilioConnector) GetConfig() (example string, data any, upgrader configupgrade.Upgrader) {\n\treturn ExampleConfig, &tc.Config, configupgrade.SimpleUpgrader(upgradeConfig)\n}\n```\n |\nand you'd have `pkg/connector/example-config.yaml` with\n|\n1\n2\n |\n```\n# A description of the field\nmy_fancy_field: this is the default value\n```\n |\n### [`GetDBMetaTypes`](#getdbmetatypes)\nThe central bridge module has its own database where it stores things like room mappings, remote user info, logins, etc. The database columns cover fields that all bridges need like displaynames, but there are often a few network-specific fields that are necessary as well. To support such fields, the database also has a `metadata` column, which is just arbitrary JSON data.\nTo make the JSON data easier to consume, the network connector must provide typed structs for the tables it wants to add metadata to. The `GetDBMetaTypes` function returns functions that create new instances of each of the structs.\nFor Twilio, we want to store the credentials in UserLogins, but don't really need any other metadata, so we can omit all the other fields.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n |\n```\nfunc (tc *TwilioConnector) GetDBMetaTypes() database.MetaTypes {\n\treturn database.MetaTypes{\n\t\tPortal:   nil,\n\t\tGhost:    nil,\n\t\tMessage:  nil,\n\t\tReaction: nil,\n\t\tUserLogin: func() any {\n\t\t\treturn &UserLoginMetadata{}\n\t\t},\n\t}\n}\ntype UserLoginMetadata struct {\n\tPhone      string `json:\"phone\"`\n\tPhoneSID   string `json:\"phone_sid\"`\n\tAuthToken  string `json:\"auth_token\"`\n\tAccountSID string `json:\"account_sid\"`\n}\n```\n |\nAfter the struct is defined, we can safely cast the `Metadata` field in the relevant database structs into our metadata struct. We'll already use it in `LoadUserLogin` below. We also set the values in the login section.\n### [`LoadUserLogin`](#loaduserlogin)\n`LoadUserLogin` is called when the bridge wants to prepare an existing login for connection. This is where the `NetworkAPI` interface comes in: the primary purpose is to fill the `Client` property of `UserLogin` with the network client. This function should not do anything else, actually connecting to the remote network (if applicable) happens later in `NetworkAPI.Connect`.\nWe'll initialize the go-twilio client here. We're also initializing a `RequestValidator`. It's used for the webhooks, which we'll come back to later.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n15\n |\n```\nfunc (tc *TwilioConnector) LoadUserLogin(ctx context.Context, login *bridgev2.UserLogin) error {\n\tmeta := login.Metadata.(*UserLoginMetadata)\n\trestClient := twilio.NewRestClientWithParams(twilio.ClientParams{\n\t\tUsername:   meta.AccountSID,\n\t\tPassword:   meta.AuthToken,\n\t\tAccountSid: meta.AccountSID,\n\t})\n\tvalidator := tclient.NewRequestValidator(meta.AuthToken)\n\tlogin.Client = &TwilioClient{\n\t\tUserLogin:        login,\n\t\tTwilio:           restClient,\n\t\tRequestValidator: validator,\n\t}\n\treturn nil\n}\n```\n |\n## [The network API](#the-network-api)\nNext, we'll need to actually define `TwilioClient` and implement the `NetworkAPI`.\n|\n1\n2\n3\n4\n5\n6\n7\n |\n```\ntype TwilioClient struct {\n\tUserLogin        *bridgev2.UserLogin\n\tTwilio           *twilio.RestClient\n\tRequestValidator client.RequestValidator\n}\nvar _ bridgev2.NetworkAPI = (*TwilioClient)(nil)\n```\n |\nLike with the network connector, we'll do the same interface implementation assertion, In this case it's not technically necessary, as we're already assigning a `&TwilioClient{}` to `UserLogin.Client`, which does the same check. However, if you implement any of the optional extra interfaces, then the explicit assertions become very useful, as there's nothing else ensuring the correct functions are implemented.\n### [`Connect`](#connect)\nFor most networks which use persistent connections, this is where you'd set up the connection. Twilio doesn't use a persistent connection, so technically we don't need to do anything here. However, we should still check access token validity here.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n |\n```\nfunc (tc *TwilioClient) Connect(ctx context.Context) {\n\tphoneNumbers, err := tc.Twilio.Api.ListIncomingPhoneNumber(nil)\n\tif err != nil {\n\t\ttc.UserLogin.BridgeState.Send(status.BridgeState{\n\t\t\tStateEvent: status.StateBadCredentials,\n\t\t\tError:      \"twilio-api-error\",\n\t\t\tMessage:    \"Failed to list phone numbers\",\n\t\t\tInfo: map[string]any{\n\t\t\t\t\"go_error\": err.Error(),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\tmeta := tc.UserLogin.Metadata.(*UserLoginMetadata)\n\tvar numberFound bool\n\tfor _, number := range phoneNumbers {\n\t\tif number.PhoneNumber != nil && *number.PhoneNumber == meta.Phone {\n\t\t\tnumberFound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !numberFound {\n\t\ttc.UserLogin.BridgeState.Send(status.BridgeState{\n\t\t\tStateEvent: status.StateBadCredentials,\n\t\t\tError:      \"twilio-phone-not-found\",\n\t\t\tMessage:    fmt.Sprintf(\"phone number %s not found on account\", meta.Phone),\n\t\t})\n\t\treturn\n\t}\n}\n```\n |\n**Update March 2025:** Previously this function was allowed to return errors, but it was later updated to not allow that. Instead, any connection errors are signaled using the `tc.UserLogin.BridgeState` queue.\n### [`Disconnect`](#disconnect)\nFor networks with persistent connections, Disconnect should tear down the connection. Twilio doesn't have a persistent connection, so we don't need to do anything here.\n|\n1\n |\n```\nfunc (tc *TwilioClient) Disconnect() {}\n```\n |\n### [`IsLoggedIn`](#isloggedin)\nOn some networks, logins can be invalidated, so this function is used to check if the login is still valid. For Twilio, we'll just return true. Note that this method is not meant to do any IO, it should just return cached values.\n|\n1\n2\n3\n |\n```\nfunc (tc *TwilioClient) IsLoggedIn() bool {\n\treturn true\n}\n```\n |\n### [`LogoutRemote`](#logoutremote)\nThis method is meant to invalidate remote network credentials and disconnect from the network. Since Twilio doesn't have credentials that can be invalidated, nor a persistent connection that can be disconnected, we don't need to do anything here.\n|\n1\n |\n```\nfunc (tc *TwilioClient) LogoutRemote(ctx context.Context) {}\n```\n |\n### [`GetCapabilities`](#getcapabilities-1)\nThis is similar to the network connector's GetCapabilities method, but is scoped to a user login and a portal. Currently, these fields are only used to check events before passing them to the network connector. Some of the fields are not used at all yet. The plan is to also send these fields to the room as a state event, so that clients could display limits directly to the user. The state event will likely use [MSC4110](https://github.com/matrix-org/matrix-spec-proposals/pull/4110) (or at least something similar).\nFor now, we don't really need to define any fields, but let's include Twilio's maximum message length.\n|\n1\n2\n3\n4\n5\n |\n```\nfunc (tc *TwilioClient) GetCapabilities(ctx context.Context, portal *bridgev2.Portal) *event.RoomFeatures {\n\treturn &event.RoomFeatures{\n\t\tMaxTextLength: 1600,\n\t}\n}\n```\n |\n**Update March 2025:** As of January 2025, the old capability system in mautrix-go has been redone and is now sent as a state event to rooms. Instead of `*bridgev2.NetworkRoomCapabilities`, just return `*event.RoomFeatures` and the library will deal with sending the state event. The full schema for the state event can be found at [https://github.com/mautrix/go/blob/main/event/capabilities.d.ts](https://github.com/mautrix/go/blob/main/event/capabilities.d.ts).\n## [Identifiers](#identifiers)\nBefore we get to the next functions in `NetworkAPI`, we'll need to cover network identifiers. Network IDs are opaque identifiers for various things on the remote network: logins, users, chats, messages, etc. Each identifier has its own type in the networkid module, which ensures that you can't accidentally mix up types. All the types are just strings behind the scenes.\nAll identifiers are generated by the network connector and won't be parsed by any other component. Other components also will not make any assumptions about different identifier types being similar, but the network connector itself is of course allowed to define some types are equal. For example, most networks (but not all) will define that `UserLoginID`s are the same as `UserID`s. However, identifiers do have some uniqueness expectations that the network connector must meet.\nFor Twilio, we'll define the identifiers as follows:\n-   `UserID`s are E.164 phone numbers without the leading `+`.\n-   `PortalID`s are equivalent to `UserID`s.\n-   `MessageID`s are Twilio message SIDs.\n-   `UserLoginID`s are account SID and phone SID joined with a `:`.\nFor convenience, we'll define some functions to cast strings into those types:\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n |\n```\nfunc makeUserID(e164Phone string) networkid.UserID {\n\treturn networkid.UserID(strings.TrimLeft(e164Phone, \"+\"))\n}\nfunc makePortalID(e164Phone string) networkid.PortalID {\n\treturn networkid.PortalID(strings.TrimLeft(e164Phone, \"+\"))\n}\nfunc makeUserLoginID(accountSID, phoneSID string) networkid.UserLoginID {\n\treturn networkid.UserLoginID(fmt.Sprintf(\"%s:%s\", accountSID, phoneSID))\n}\n```\n |\nSee the [networkid module godocs](https://pkg.go.dev/maunium.net/go/mautrix/bridgev2/networkid) for docs on all the different types of identifiers.\n### [`IsThisUser`](#isthisuser)\nSince `UserID`s and `UserLoginID`s are not interchangeable, we need to provide some way for the bridge to determine if a given user ID belongs to a user login. For most networks where user and login IDs are the same, you can just check for equality.\nFor this bridge, we're segregating different logins to have their own portals, which means this function is not actually necessary, and we could just hardcode it to return `false`. It's not hard to implement though, so let's do it anyway.\n|\n1\n2\n3\n4\n |\n```\nfunc (tc *TwilioClient) IsThisUser(ctx context.Context, userID networkid.UserID) bool {\n\tmeta := tc.UserLogin.Metadata.(*UserLoginMetadata)\n\treturn makeUserID(meta.Phone) == userID\n}\n```\n |\nIf you were to define UserLoginID and UserID the same way, you could have an even simpler check:\n|\n1\n2\n3\n |\n```\nfunc (tc *NotTwilioClient) IsThisUser(ctx context.Context, userID networkid.UserID) bool {\n\treturn networkid.UserID(tc.UserLogin.ID) == userID\n}\n```\n |\n### [`GetChatInfo`](#getchatinfo)\n`GetChatInfo` returns the info for a given chat. All the values in the response struct are pointers, which means they can be omitted to tell the bridge that the corresponding room state event shouldn't be modified. For example, DMs generally don't have names, topics or avatars. However, even DMs do have members. The member list should always include all participants, so both the Matrix user and the remote user in DMs.\nWe're only handling DMs in this bridge, so we don't need to return anything other than the member list.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n |\n```\nfunc (tc *TwilioClient) GetChatInfo(ctx context.Context, portal *bridgev2.Portal) (*bridgev2.ChatInfo, error) {\n\treturn &bridgev2.ChatInfo{\n\t\tMembers: &bridgev2.ChatMemberList{\n\t\t\tIsFull: true,\n\t\t\tMembers: []bridgev2.ChatMember{\n\t\t\t\t{\n\t\t\t\t\tEventSender: bridgev2.EventSender{\n\t\t\t\t\t\tIsFromMe: true,\n\t\t\t\t\t\tSender:   makeUserID(tc.UserLogin.Metadata.(*UserLoginMetadata).Phone),\n\t\t\t\t\t},\n\t\t\t\t\t// This could be omitted, but leave it in to be explicit.\n\t\t\t\t\tMembership: event.MembershipJoin,\n\t\t\t\t\t// Make the user moderator, so they can adjust the room metadata if they want to.\n\t\t\t\t\tPowerLevel: ptr.Ptr(50),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tEventSender: bridgev2.EventSender{\n\t\t\t\t\t\tSender: networkid.UserID(portal.ID),\n\t\t\t\t\t},\n\t\t\t\t\tMembership: event.MembershipJoin,\n\t\t\t\t\tPowerLevel: ptr.Ptr(50),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n```\n |\n### [`GetUserInfo`](#getuserinfo)\n`GetUserInfo` is basically the same as `GetChatInfo`, but it returns info for a given user instead of a chat. The returned info will be applied as the ghost user's profile on Matrix.\nBecause we're bridging SMS and don't have a contact list, we don't really have any other info than the phone number itself. If we wanted to be fancy, we could format the phone number nicely for `Name`, but I couldn't find any convenient libraries similar to phonenumbers for Python.\nIn addition to `Name`, we set `Identifiers` which is a list of URIs that represent the user. In this case, we're using the `tel:` scheme, but you could also include network-specific @usernames with a custom scheme here.\n|\n1\n2\n3\n4\n5\n6\n |\n```\nfunc (tc *TwilioClient) GetUserInfo(ctx context.Context, ghost *bridgev2.Ghost) (*bridgev2.UserInfo, error) {\n\treturn &bridgev2.UserInfo{\n\t\tIdentifiers: []string{fmt.Sprintf(\"tel:+%s\", ghost.ID)},\n\t\tName:        ptr.Ptr(fmt.Sprintf(\"+%s\", ghost.ID)),\n\t}, nil\n}\n```\n |\n## [The login process](#the-login-process)\nIn the first section about the network connector, we skipped the `GetLoginFlows` and `CreateLogin` functions, so let's get back to those.\n`GetLoginFlows` returns the ways that can be used to log into the bridge. Just an internal ID, a human-readable name and a brief description. The internal ID of the flow the user picked is then passed to `CreateLogin`. The return type of `CreateLogin` is the third and final primary interface, `LoginProcess`.\nLogin process is meant to be a simple abstraction over login flows to arbitrary remote networks. It has three different step types that can hopefully be used to build any login flow there is:\n-   User input: fairly self-explanatory, ask the user to give values for one or more fields.\n-   Cookies: display a webview to the user and extract cookies, localStorage or other things after completion. For non-graphical logins (like using the bridge bot), this will ask the user to manually go to the website and extract the relevant values. If only cookies are necessary, the extraction can be done by using the \"Copy as cURL\" feature in browser devtools and pasting the result to the bridge bot.\n-   Display and wait: display something to the user, then wait until the remote network returns a response. This is used for things like QR logins or other flows where the user has to do something on an existing login.\nEvery step also has an internal identifier (reverse java package naming style is recommended), general instructions for the entire step, and type-specific parameters.\nIn addition to the three real step types, there's a fourth special type indicating the login was successful.\n### [`GetLoginFlows` & `CreateLogin`](#getloginflows--createlogin)\nIn the case of Twilio, the user just needs to provide their API keys, so we'll use the user input type. First, we'll implement the two functions in the network connector.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n |\n```\nfunc (tc *TwilioConnector) GetLoginFlows() []bridgev2.LoginFlow {\n\treturn []bridgev2.LoginFlow{{\n\t\tName:        \"Auth token\",\n\t\tDescription: \"Log in with your Twilio account SID and auth token\",\n\t\tID:          \"auth-token\",\n\t}}\n}\nfunc (tc *TwilioConnector) CreateLogin(ctx context.Context, user *bridgev2.User, flowID string) (bridgev2.LoginProcess, error) {\n\tif flowID != \"auth-token\" {\n\t\treturn nil, fmt.Errorf(\"unknown login flow ID\")\n\t}\n\treturn &TwilioLogin{User: user}, nil\n}\n```\n |\n### [`TwilioLogin`](#twiliologin)\nThen we need to define the actual `TwilioLogin` type that `CreateLogin` returns:\n|\n1\n2\n3\n4\n5\n6\n7\n |\n```\ntype TwilioLogin struct {\n\tUser         *bridgev2.User\n\tClient       *twilio.RestClient\n\tPhoneNumbers []twilioPhoneNumber\n\tAccountSID   string\n\tAuthToken    string\n}\n```\n |\nWe have a bunch of extra fields in addition to the `User`. They are used to store data when there are multiple login steps. Specifically, if the Twilio account has more than one phone number, we'll return a second step asking which one to use.\nHere the interface implementation assertion is quite important. Returning `TwilioLogin` from `CreateLogin` ensures that the interface implements `bridgev2.LoginProcess`, but most login flows also need to implement one or more of the step type specific interfaces. In this case, we're using the user input type, so we want to make sure `bridgev2.LoginProcessUserInput` is implemented.\n|\n1\n |\n```\nvar _ bridgev2.LoginProcessUserInput = (*TwilioLogin)(nil)\n```\n |\nAfter that, we'll have three methods that need to be implemented: `Start`, `SubmitUserInput` and `Cancel`.\n### [`Start`](#start-1)\nStart returns the first step of the login process. For other networks that require a connection, this is probably also where the connection would be established. For Twilio, we don't have anything to connect to initially, we just want the user to provide their account SID and auth token.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n |\n```\nfunc (tl *TwilioLogin) Start(ctx context.Context) (*bridgev2.LoginStep, error) {\n\treturn &bridgev2.LoginStep{\n\t\tType:         bridgev2.LoginStepTypeUserInput,\n\t\tStepID:       \"fi.mau.twilio.enter_api_keys\",\n\t\tInstructions: \"\",\n\t\tUserInputParams: &bridgev2.LoginUserInputParams{\n\t\t\tFields: []bridgev2.LoginInputDataField{\n\t\t\t\t{\n\t\t\t\t\tType:    bridgev2.LoginInputFieldTypeUsername,\n\t\t\t\t\tID:      \"account_sid\",\n\t\t\t\t\tName:    \"Twilio account SID\",\n\t\t\t\t\tPattern: `^AC[0-9a-fA-F]{32}$`,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType:    bridgev2.LoginInputFieldTypePassword,\n\t\t\t\t\tID:      \"auth_token\",\n\t\t\t\t\tName:    \"Twilio auth token\",\n\t\t\t\t\tPattern: \"^[0-9a-f]{32}$\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, nil\n}\n```\n |\n### [`SubmitUserInput` and finishing the login](#submituserinput-and-finishing-the-login)\nAfter the user provides the values, we'll get a call to `SubmitUserInput`.\nThis will be a more complicated function. First, we need to validate the credentials and get a list of phone numbers available on the Twilio account. After that, we either finish the login if there's only one number, or ask the user which one to use if there are multiple. If we ask the user, then we'll get another call to `SubmitUserInput`, which means we need to remember the data from the first call. After a successful login, we prepare the `UserLogin` instance.\nLet's split up the function to keep it more readable. First, `SubmitUserInput` itself. We have two paths, so we'll just split it into two calls. If `Client` is not set in `TwilioLogin`, we're in the first step where we want API keys. If it is set, we want to choose a phone number.\n|\n1\n2\n3\n4\n5\n6\n7\n |\n```\nfunc (tl *TwilioLogin) SubmitUserInput(ctx context.Context, input map[string]string) (*bridgev2.LoginStep, error) {\n\tif tl.Client == nil {\n\t\treturn tl.submitAPIKeys(ctx, input)\n\t} else {\n\t\treturn tl.submitChosenPhoneNumber(ctx, input)\n\t}\n}\n```\n |\nThen the API key submit function.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n |\n```\ntype twilioPhoneNumber struct {\n\tSID          string\n\tNumber       string\n\tPrettyNumber string\n}\nfunc (tl *TwilioLogin) submitAPIKeys(ctx context.Context, input map[string]string) (*bridgev2.LoginStep, error) {\n\ttl.AccountSID = input[\"account_sid\"]\n\ttl.AuthToken = input[\"auth_token\"]\n\ttwilioClient := twilio.NewRestClientWithParams(twilio.ClientParams{\n\t\tUsername:   tl.AccountSID,\n\t\tPassword:   tl.AuthToken,\n\t\tAccountSid: tl.AccountSID,\n\t})\n\t// Get the list of phone numbers. This doubles as a way to verify the credentials are valid.\n\tphoneNumbers, err := twilioClient.Api.ListIncomingPhoneNumber(nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to list phone numbers: %w\", err)\n\t}\n\tvar numbers []twilioPhoneNumber\n\tfor _, number := range phoneNumbers {\n\t\tif number.Status == nil || number.PhoneNumber == nil || *number.Status != \"in-use\" {\n\t\t\tcontinue\n\t\t}\n\t\tnumbers = append(numbers, twilioPhoneNumber{\n\t\t\tSID:          *number.Sid,\n\t\t\tNumber:       *number.PhoneNumber,\n\t\t\tPrettyNumber: *number.FriendlyName,\n\t\t})\n\t}\n\ttl.Client = twilioClient\n\ttl.PhoneNumbers = numbers\n\tif len(numbers) == 0 {\n\t\treturn nil, fmt.Errorf(\"no active phone numbers found\")\n\t} else if len(numbers) == 1 {\n\t\treturn tl.finishLogin(ctx, numbers[0])\n\t} else {\n\t\tphoneNumberList := make([]string, len(numbers))\n\t\tfor i, number := range numbers {\n\t\t\tphoneNumberList[i] = fmt.Sprintf(\"* %s\", number.Number)\n\t\t}\n\t\treturn &bridgev2.LoginStep{\n\t\t\tType:         bridgev2.LoginStepTypeUserInput,\n\t\t\tStepID:       \"fi.mau.twilio.choose_number\",\n\t\t\tInstructions: \"Your Twilio account has multiple phone numbers. Please choose one:\\n\\n\" + strings.Join(phoneNumberList, \"\\n\"),\n\t\t\tUserInputParams: &bridgev2.LoginUserInputParams{\n\t\t\t\tFields: []bridgev2.LoginInputDataField{{\n\t\t\t\t\tType: bridgev2.LoginInputFieldTypePhoneNumber,\n\t\t\t\t\tID:   \"chosen_number\",\n\t\t\t\t\tName: \"Phone number\",\n\t\t\t\t}},\n\t\t\t},\n\t\t}, nil\n\t}\n}\n```\n |\nChoosing the phone number is fairly simple, as we already have a valid token and have fetched the list of phone numbers. We just need to find the phone number the user chose.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n |\n```\nfunc (tl *TwilioLogin) submitChosenPhoneNumber(ctx context.Context, input map[string]string) (*bridgev2.LoginStep, error) {\n\tnumberIdx := slices.IndexFunc(tl.PhoneNumbers, func(e twilioPhoneNumber) bool {\n\t\treturn e.Number == input[\"chosen_number\"]\n\t})\n\tif numberIdx == -1 {\n\t\t// We could also return a new LoginStep here if we wanted to allow the user to retry.\n\t\t// Errors are always fatal, so returning an error here will cancel the login process.\n\t\treturn nil, fmt.Errorf(\"invalid phone number\")\n\t}\n\treturn tl.finishLogin(ctx, tl.PhoneNumbers[numberIdx])\n}\n```\n |\nFinally, the finish function, which can be called from either path and creates the `UserLogin` object. In addition to creating the object, we also send our webhook URL to Twilio. We'll define the `GetWebhookURL` function later when implementing `ReceiveMessages`.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n |\n```\nfunc (tl *TwilioLogin) finishLogin(ctx context.Context, phoneNumber twilioPhoneNumber) (*bridgev2.LoginStep, error) {\n\tul, err := tl.User.NewLogin(ctx, &database.UserLogin{\n\t\tID: makeUserLoginID(tl.AccountSID, phoneNumber.SID),\n\t\tRemoteName: phoneNumber.PrettyNumber,\n\t\tMetadata: &UserLoginMetadata{\n\t\t\tPhone:      phoneNumber.Number,\n\t\t\tPhoneSID:   phoneNumber.SID,\n\t\t\tAuthToken:  tl.AuthToken,\n\t\t\tAccountSID: tl.AccountSID,\n\t\t},\n\t}, &bridgev2.NewLoginParams{\n\t\tLoadUserLogin: func(ctx context.Context, login *bridgev2.UserLogin) error {\n\t\t\tlogin.Client = &TwilioClient{\n\t\t\t\tUserLogin:        login,\n\t\t\t\tTwilio:           tl.Client,\n\t\t\t\tRequestValidator: tclient.NewRequestValidator(tl.AuthToken),\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttc := ul.Client.(*TwilioClient)\n\t// In addition to creating the UserLogin, we'll also want to set the webhook URL for the phone number.\n\t_, err = tc.Twilio.Api.UpdateIncomingPhoneNumber(phoneNumber.SID, &openapi.UpdateIncomingPhoneNumberParams{\n\t\tSmsMethod: ptr.Ptr(http.MethodPost),\n\t\tSmsUrl:    ptr.Ptr(tc.GetWebhookURL()),\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to set webhook URL for phone number: %w\", err)\n\t}\n\t// Finally, return the special complete step indicating the login was successful.\n\t// It doesn't have any params other than the UserLogin we just created.\n\treturn &bridgev2.LoginStep{\n\t\tType:         bridgev2.LoginStepTypeComplete,\n\t\tStepID:       \"fi.mau.twilio.complete\",\n\t\tInstructions: \"Successfully logged in\",\n\t\tCompleteParams: &bridgev2.LoginCompleteParams{\n\t\t\tUserLoginID: ul.ID,\n\t\t\tUserLogin:   ul,\n\t\t},\n\t}, nil\n}\n```\n |\n### [`Cancel`](#cancel)\nCancel is called if the user cancels the login process. For networks that create some sort of connection, you should tear it down here. Since Twilio doesn't have any such connections, we don't need to do anything.\n|\n1\n |\n```\nfunc (tl *TwilioLogin) Cancel() {}\n```\n |\nNote that this method is not called at the end of the login, nor if the login process returns errors. In both of those cases, you need to disconnect yourself. Errors returned by any step of the process are treated as fatal. If you want to prompt the user to retry, you should return another login step with the appropriate instructions. This is also how refreshing QR codes should be done.\n## [Bridging messages](#bridging-messages)\nWith everything else out of the way, let's get to the main point: bridging messages between Twilio and Matrix.\n### [Twilio → Matrix](#twilio--matrix)\nTo receive messages from Twilio, we need to implement the `ReceiveMessages` function that we created to handle HTTP webhooks. Before that, let's define the webhook URLs, which was used in the login section.\nWe don't need to check if `Matrix` implements `MatrixConnectorWithServer`, because we already validated that in `Start`. We can just cast it to access `GetPublicAddress` and then append our path. We include the user login ID in the in order to correctly route incoming webhooks.\n|\n1\n2\n3\n4\n |\n```\nfunc (tc *TwilioClient) GetWebhookURL() string {\n\tserver := tc.UserLogin.Bridge.Matrix.(bridgev2.MatrixConnectorWithServer)\n\treturn fmt.Sprintf(\"%s/_twilio/%s/receive\", server.GetPublicAddress(), tc.UserLogin.ID)\n}\n```\n |\nThe `ReceiveMessages` function contains a lot of boilerplate code that the Twilio library could handle, but doesn't. The main bridge-specific code is finding the user login based on the path parameter.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n |\n```\nfunc (tc *TwilioConnector) ReceiveMessage(w http.ResponseWriter, r *http.Request) {\n\t// First make sure the signature header is present and that the request body is valid form data.\n\tsig := r.Header.Get(\"X-Twilio-Signature\")\n\tif sig == \"\" {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t_, _ = w.Write([]byte(\"Missing signature header\\n\"))\n\t\treturn\n\t}\n\tparams := make(map[string]string)\n\terr := r.ParseForm()\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t_, _ = w.Write([]byte(\"Failed to parse form data\\n\"))\n\t\treturn\n\t}\n\tfor key, value := range r.PostForm {\n\t\tparams[key] = value[0]\n\t}\n\t// Get the user login based on the path. We need it to find the right token\n\t// to use for validating the request signature.\n\tloginID := r.PathValue(\"loginID\")\n\tlogin := tc.br.GetCachedUserLoginByID(networkid.UserLoginID(loginID))\n\tif login == nil {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\t_, _ = w.Write([]byte(\"Unrecognized login ID in request path\\n\"))\n\t\treturn\n\t}\n\tclient := login.Client.(*TwilioClient)\n\t// Now that we have the client, validate the request.\n\tif !client.RequestValidator.Validate(client.GetWebhookURL(), params, sig) {\n\t\tw.WriteHeader(http.StatusForbidden)\n\t\t_, _ = w.Write([]byte(\"Invalid signature\\n\"))\n\t\treturn\n\t}\n\t// Pass the request to the client for handling. This is where everything actually happens.\n\tclient.HandleWebhook(r.Context(), params)\n\t// We don't want to respond immediately, so just send a blank TwiML response.\n\ttwimlResult, err := twiml.Messages(nil)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t} else {\n\t\tw.Header().Set(\"Content-Type\", \"text/xml\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\t_, _ = w.Write([]byte(twimlResult))\n\t}\n}\n```\n |\nFinally, we need the actual handling function. All we really need to do is pass the event to the central bridge. To do that, we need to extract metadata like the portal and message IDs, and provide a converter function to actually convert the message into a Matrix event.\nSimple connectors can use the types in the `simplevent` package as remote events, but for more complicated connectors, it often makes sense to create an interface which implements `bridgev2.RemoteEvent`. That way, the interface methods can figure out the appropriate data to return, instead of having to fill a struct for every different event type.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n |\n```\nfunc (tc *TwilioClient) HandleWebhook(ctx context.Context, params map[string]string) {\n\ttc.UserLogin.Bridge.QueueRemoteEvent(tc.UserLogin, &simplevent.Message[map[string]string]{\n\t\tEventMeta: simplevent.EventMeta{\n\t\t\tType: bridgev2.RemoteEventMessage,\n\t\t\tLogContext: func(c zerolog.Context) zerolog.Context {\n\t\t\t\treturn c.\n\t\t\t\t\tStr(\"from\", params[\"From\"]).\n\t\t\t\t\tStr(\"message_id\", params[\"MessageSid\"])\n\t\t\t},\n\t\t\tPortalKey: networkid.PortalKey{\n\t\t\t\tID:       makePortalID(params[\"From\"]),\n\t\t\t\tReceiver: tc.UserLogin.ID,\n\t\t\t},\n\t\t\tCreatePortal: true,\n\t\t\tSender: bridgev2.EventSender{\n\t\t\t\tSender: makeUserID(params[\"From\"]),\n\t\t\t},\n\t\t\tTimestamp: time.Now(),\n\t\t},\n\t\tData:               params,\n\t\tID:                 networkid.MessageID(params[\"MessageSid\"]),\n\t\tConvertMessageFunc: tc.convertMessage,\n\t})\n}\n```\n |\nLet's go over each of the fields we're filling:\n-   `Type` is the event type. It's a normal message.\n-   `LogContext` is a function that adds structured fields to the event handler's zerolog logger. By default, the logger only has the portal key and user login ID, so other things should be added here.\n-   `PortalKey` is the ID of the chat. This is a combination of a portal ID and an optional \"receiver\". Receivers can be used to segregate portals, so that if multiple logged-in users have the same chat, they'll still get separate portal rooms. Most networks should use receivers for DMs, but it is also possible to use them for all rooms if you don't want any portals to be shared. If there's no receiver, then users will be added to the same Matrix room.\n-   `Data` is the event data itself. This is only here so that it can be passed to the message convert function.\n-   `CreatePortal` tells the central bridge module that we want it to create a portal room if one doesn't already exist for the given portal key. The bridge will then call `GetChatInfo` to get the info of the chat to create.\n-   `ID` is the message ID.\n-   `Sender` is the sender of the message. For networks where the user can send messages from other clients, you should also fill `IsFromMe` and/or `SenderLogin` appropriately. For Twilio, we'll just assume you can't send messages from other clients (we don't support receiving those anyway), so we don't need to fill anything else than `Sender`.\n-   `Timestamp` is the message timestamp. Twilio doesn't seem to provide timestamps, so we just declare that the message was sent now.\n-   `ConvertMessageFunc` is a function that gets `Data`, the `Portal` object as well as a `MatrixAPI` and returns the Matrix events that should be sent.\nThe convert message function is very simple, as we only support plain text messages for now. If you wanted to bridge media, you'd download it from the remote network and reupload it to Matrix using `intent.UploadMedia`.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n |\n```\nfunc (tc *TwilioClient) convertMessage(ctx context.Context, portal *bridgev2.Portal, intent bridgev2.MatrixAPI, data map[string]string) (*bridgev2.ConvertedMessage, error) {\n\treturn &bridgev2.ConvertedMessage{\n\t\tParts: []*bridgev2.ConvertedMessagePart{{\n\t\t\tType: event.EventMessage,\n\t\t\tContent: &event.MessageEventContent{\n\t\t\t\tMsgType: event.MsgText,\n\t\t\t\tBody:    data[\"Body\"],\n\t\t\t},\n\t\t}},\n\t}, nil\n}\n```\n |\n### [Matrix → Twilio](#matrix--twilio)\nTo receive messages from Matrix, we need to implement the `HandleMatrixMessage` function that we skipped over in the network API section. Responding is very simple, we just call the Twilio API and return the message ID.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n15\n16\n |\n```\nfunc (tc *TwilioClient) HandleMatrixMessage(ctx context.Context, msg *bridgev2.MatrixMessage) (message *bridgev2.MatrixMessageResponse, err error) {\n\tresp, err := tc.Twilio.Api.CreateMessage(&openapi.CreateMessageParams{\n\t\tTo:   ptr.Ptr(fmt.Sprintf(\"+%s\", msg.Portal.ID)),\n\t\tFrom: ptr.Ptr(tc.UserLogin.Metadata.(*UserLoginMetadata).Phone),\n\t\tBody: ptr.Ptr(msg.Content.Body),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &bridgev2.MatrixMessageResponse{\n\t\tDB: &database.Message{\n\t\t\tID:       networkid.MessageID(*resp.Sid),\n\t\t\tSenderID: makeUserID(*resp.From),\n\t\t},\n\t}, nil\n}\n```\n |\n## [Bonus feature: starting chats](#bonus-feature-starting-chats)\nWe've implemented everything that's strictly necessary for a bridge to work, but let's add one optional feature on top: creating new portal rooms. To do this, we'll add another interface assertion for `TwilioClient`:\n|\n1\n |\n```\nvar _ bridgev2.IdentifierResolvingNetworkAPI = (*TwilioClient)(nil)\n```\n |\nThe interface requires us to implement the `ResolveIdentifier` method, which is used for both checking if an identifier is reachable and actually starting a direct chat. There are further optional interfaces for creating group chats with resolved identifiers, but we don't support group chats at all here, so let's stick to DMs.\nThe function just gets a raw string which is provided by the user. If you wanted to make a fancy Twilio bridge, you'd probably use the lookup API to get more info about the phone number, but we'll just do basic validation to make sure the input is a number.\nAfter validating the number, we'll get the ghost and portal objects as well as their info. The info for both is the same shape as the `GetUserInfo` and `GetChatInfo` methods, so we'll just call them instead of duplicating the same behavior.\nWe don't actually care about the `createChat` parameter here, because Twilio doesn't require creating chats explicitly. For networks which do require creating chats, you'd need to use the bool to decide whether it should be created or not. The `Chat` field in the response is mandatory when `createChat` is true, but can be omitted when it's false.\nWe also don't create the portal room here: the central bridge module takes care of that using the info we return.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n |\n```\nfunc (tc *TwilioClient) ResolveIdentifier(ctx context.Context, identifier string, createChat bool) (*bridgev2.ResolveIdentifierResponse, error) {\n\te164Number, err := bridgev2.CleanPhoneNumber(identifier)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuserID := makeUserID(e164Number)\n\tportalID := networkid.PortalKey{\n\t\tID:       makePortalID(e164Number),\n\t\tReceiver: tc.UserLogin.ID,\n\t}\n\tghost, err := tc.UserLogin.Bridge.GetGhostByID(ctx, userID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get ghost: %w\", err)\n\t}\n\tportal, err := tc.UserLogin.Bridge.GetPortalByKey(ctx, portalID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get portal: %w\", err)\n\t}\n\tghostInfo, _ := tc.GetUserInfo(ctx, ghost)\n\tportalInfo, _ := tc.GetChatInfo(ctx, portal)\n\treturn &bridgev2.ResolveIdentifierResponse{\n\t\tGhost:    ghost,\n\t\tUserID:   userID,\n\t\tUserInfo: ghostInfo,\n\t\tChat: &bridgev2.CreateChatResponse{\n\t\t\tPortal:     portal,\n\t\t\tPortalKey:  portalID,\n\t\t\tPortalInfo: portalInfo,\n\t\t},\n\t}, nil\n}\n```\n |\nTechnically we don't even need to get the portal object: the central bridge module would get it automatically based on `PortalID` if `Portal` is omitted. However, I wanted to reuse `GetChatInfo` and didn't want to refactor it to take a plain `PortalID` instead of a whole `Portal`.\nThat's everything needed from the connector to enable starting chats. With that function implemented, the `resolve-identifier` and `start-chat` bot commands as well as the corresponding provisioning APIs will work.\n## [Main function](#main-function)\nNow that we have a functional network connector, all that's left is to wrap it up with a main function. The main function goes in `cmd/mautrix-twilio/main.go`, because it's a command called mautrix-twilio rather than a part of the library.\nThe main file doesn't need to be particularly complicated. First, we define some variables to store the version. These will be set at compile time using the `-X` linker flag. We'll go over the exact flags in the next section.\n|\n1\n2\n3\n4\n5\n |\n```\nvar (\n\tTag       = \"unknown\"\n\tCommit    = \"unknown\"\n\tBuildTime = \"unknown\"\n)\n```\n |\nThen, we make the actual main function, which just creates a `BridgeMain`, gives it an instance of the connector, and runs the bridge.\n|\n 1 2 3 4 5 6 7 8 9\n10\n11\n |\n```\nfunc main() {\n\tm := mxmain.BridgeMain{\n\t\tName:        \"mautrix-twilio\",\n\t\tDescription: \"A Matrix-Twilio bridge\",\n\t\tURL:         \"https://github.com/mautrix/twilio\",\n\t\tVersion:     \"0.1.0\",\n\t\tConnector:   &connector.TwilioConnector{},\n\t}\n\tm.InitVersion(Tag, Commit, BuildTime)\n\tm.Run()\n}\n```\n |\nThat's it. The `mxmain` module is designed to wrap all the parts together to produce a traditional single-network bridge.\n### [Building the bridge](#building-the-bridge)\nTo build the bridge, you can simply use `go build ./cmd/mautrix-twilio` in the repo root directory. However, to be slightly fancier, we also want to fill the version info variables that we added to main. To do that, we'll make a script called `build.sh` in the repo root.\n|\n1\n2\n3\n4\n |\n```\n#!/bin/sh\nMAUTRIX_VERSION=$(cat go.mod | grep 'maunium.net/go/mautrix ' | awk '{ print $2 }' | head -n1)\nGO_LDFLAGS=\"-s -w -X main.Tag=$(git describe --exact-match --tags 2>/dev/null) -X main.Commit=$(git rev-parse HEAD) -X 'main.BuildTime=`date -Iseconds`' -X 'maunium.net/go/mautrix.GoModVersion=$MAUTRIX_VERSION'\"\ngo build -ldflags=\"$GO_LDFLAGS\" ./cmd/mautrix-twilio \"$@\"\n```\n |\nLet's break it down:\nThe first line gets the version of mautrix-go in use by somewhat crudely parsing the `go.mod` file. Since there's a lot of code from mautrix-go being used, it's useful to have the exact commit embedded rather than having to figure it out based on the bridge version.\nThe second line defines all the linker flags. `-s` and `-w` are standard flags to strip debug information and DWARF symbols, respectively. They make the binary smaller, but also make it harder to debug using debuggers. Generally all you need in production is stack traces, and fortunately those remain intact.\nEach `-X` flag sets the value of a variable in the binary. We set four variables:\n-   If we're on a Git tag, we want to set `main.Tag` to the tag name. Otherwise, it's set to an empty string. To do this, we want both `--exact-match` (don't output anything unless we're on a tag) and `--tags` (consider all tags instead of only annotated ones). If you use annotated tags for releases, you may want to remove `--tags`. The `2>/dev/null` part is needed to suppress the error message when we're not on a tag.\n-   `Commit` is fairly straightforward, it's just the commit hash of the current commit (`HEAD`), which is easiest to find using `git rev-parse HEAD`.\n-   `BuildTime` is the current time in ISO 8601/RFC3339 format.\n-   Finally, we set `GoModVersion` inside mautrix-go to the version we extracted from `go.mod`.\nWith the linker flags defined, the last step is to actually call `go build` with those flags and tell it to build our command. The `\"$@\"` at the end passes any arguments given to the script to the `go build` command. For example, if you wanted to output to a different path, you could use `./build.sh -o example.exe`.\n### [Running the bridge](#running-the-bridge)\nFinally, we have a bridge, it's compiled, all that's left is to run and use it. At this point, you can pretty much just follow [the docs](https://docs.mau.fi/bridges/go/setup.html) starting from the \"Configuring and running\" part.\n1.  Generate the example config using `./mautrix-twilio -e` (it will be saved to `config.yaml`).\n2.  Edit the config like any other bridge.\n3.  Generate the appservice registration with `./mautrix-twilio -g`.\n4.  Pass the appservice registration to your homeserver.\n5.  Run the bridge with `./mautrix-twilio`.\nAfter the bridge is running, start a chat with the bridge bot, and send `login` to start the login process. Then send your API keys as instructed, and you're good to go!\n#### [Running with Beeper](#running-with-beeper)\nIf you're using Beeper, you can skip steps 1-4 and just tell bbctl to generate a megabridge config:\n|\n1\n |\n```\nbbctl config --type bridgev2 -o config.yaml sh-anybridgename\n```\n |\nTwilio is not the optimal example for this, as bbctl is optimized for bridges that don't require public HTTP endpoints, while Twilio does require one. You can get it to work by tweaking the config (specifically, disabling websocket mode and adding `public_address`). It should work more out of the box with bridges that don't need a HTTP server.\n## [Conclusion](#conclusion)\nIf you want to ask anything related to mautrix-go or this post, feel free to join [#go:maunium.net](https://matrix.to/#/#go:maunium.net). [This post](https://github.com/maunium/mau.fi/blob/main/blog/posts/2024-07-08-megabridge-twilio.md) also accepts pull requests.",
  "timestamp": 1762421583657,
  "title": "Writing a Twilio bridge - Tulir Asokan"
}