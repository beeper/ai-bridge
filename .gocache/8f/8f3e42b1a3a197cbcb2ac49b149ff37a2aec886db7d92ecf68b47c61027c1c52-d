// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/joshpa8c/Documents/Dev/beepAI/third_party/mautrix/crypto/libolm/pk.go:1:1
// Copyright (c) 2024 Sumner Evans
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

package libolm

// #cgo LDFLAGS: -lolm -lstdc++
// #include <olm/olm.h>
// #include <olm/pk.h>
import _ "unsafe"

import (
	"crypto/rand"
	"encoding/json"
	"runtime"
	"unsafe"

	"github.com/tidwall/sjson"

	"maunium.net/go/mautrix/crypto/canonicaljson"
	"maunium.net/go/mautrix/crypto/olm"
	"maunium.net/go/mautrix/id"
)

// PKSigning stores a key pair for signing messages.
type PKSigning struct {
	int       * /*line :29:13*/_Ctype_OlmPkSigning /*line :29:27*/
	mem       []byte
	publicKey id.Ed25519
	seed      []byte
}

// Ensure that [PKSigning] implements [olm.PKSigning].
var _ olm.PKSigning = (*PKSigning)(nil)

func pkSigningSize() uint {
	return uint(( /*line :39:14*/_Cfunc_olm_pk_signing_size /*line :39:34*/)())
}

func pkSigningSeedLength() uint {
	return uint(( /*line :43:14*/_Cfunc_olm_pk_signing_seed_length /*line :43:41*/)())
}

func pkSigningPublicKeyLength() uint {
	return uint(( /*line :47:14*/_Cfunc_olm_pk_signing_public_key_length /*line :47:47*/)())
}

func pkSigningSignatureLength() uint {
	return uint(( /*line :51:14*/_Cfunc_olm_pk_signature_length /*line :51:38*/)())
}

func newBlankPKSigning() *PKSigning {
	memory := make([]byte, pkSigningSize())
	return &PKSigning{
		int: func() *_Ctype_struct_OlmPkSigning{ _cgo0 := /*line :57:25*/unsafe.Pointer(unsafe.SliceData(memory)); _cgoCheckPointer(_cgo0, nil); return /*line :57:66*/_Cfunc_olm_pk_signing(_cgo0); }(),
		mem: memory,
	}
}

// NewPKSigningFromSeed creates a new [PKSigning] object using the given seed.
func NewPKSigningFromSeed(seed []byte) (*PKSigning, error) {
	p := newBlankPKSigning()
	p.clear()
	pubKey := make([]byte, pkSigningPublicKeyLength())
	r := func() _Ctype_size_t{ _cgo0 := /*line :68:3*/(*_Ctype_OlmPkSigning /*line :68:19*/)(p.int); _cgo1 := /*line :69:3*/unsafe.Pointer(unsafe.SliceData(pubKey)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :70:11*/(len(pubKey)); _cgo3 := /*line :71:3*/unsafe.Pointer(unsafe.SliceData(seed)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :72:11*/(len(seed)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); return /*line :73:3*/_Cfunc_olm_pk_signing_key_from_seed(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	if r == errorVal() {
		return nil, p.lastError()
	}
	p.publicKey = id.Ed25519(pubKey)
	p.seed = seed
	return p, nil
}

// NewPKSigning creates a new [PKSigning] object, containing a key pair for
// signing messages.
func NewPKSigning() (*PKSigning, error) {
	// Generate the seed
	seed := make([]byte, pkSigningSeedLength())
	_, err := rand.Read(seed)
	if err != nil {
		panic(olm.NotEnoughGoRandom)
	}
	pk, err := NewPKSigningFromSeed(seed)
	return pk, err
}

func (p *PKSigning) PublicKey() id.Ed25519 {
	return p.publicKey
}

func (p *PKSigning) Seed() []byte {
	return p.seed
}

// clear clears the underlying memory of a [PKSigning] object.
func (p *PKSigning) clear() {
	func() _Ctype_size_t{ _cgo0 := /*line :105:25*/(*_Ctype_OlmPkSigning /*line :105:41*/)(p.int); _cgoCheckPointer(_cgo0, nil); return /*line :105:50*/_Cfunc_olm_clear_pk_signing(_cgo0); }()
}

// Sign creates a signature for the given message using this key.
func (p *PKSigning) Sign(message []byte) ([]byte, error) {
	signature := make([]byte, pkSigningSignatureLength())
	r := func() _Ctype_size_t{ _cgo0 := /*line :112:3*/(*_Ctype_OlmPkSigning /*line :112:19*/)(p.int); var _cgo1 *_Ctype_uint8_t = /*line :113:3*/(*_Ctype_uint8_t /*line :113:14*/)(unsafe.Pointer(unsafe.SliceData(message))); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :114:11*/(len(message)); var _cgo3 *_Ctype_uint8_t = /*line :115:3*/(*_Ctype_uint8_t /*line :115:14*/)(unsafe.Pointer(unsafe.SliceData(signature))); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :116:11*/(len(signature)); _cgoCheckPointer(_cgo0, nil); return /*line :117:3*/_Cfunc_olm_pk_sign(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	runtime.KeepAlive(message)
	if r == errorVal() {
		return nil, p.lastError()
	}
	return signature, nil
}

// SignJSON creates a signature for the given object after encoding it to canonical JSON.
func (p *PKSigning) SignJSON(obj interface{}) (string, error) {
	objJSON, err := json.Marshal(obj)
	if err != nil {
		return "", err
	}
	objJSON, _ = sjson.DeleteBytes(objJSON, "unsigned")
	objJSON, _ = sjson.DeleteBytes(objJSON, "signatures")
	signature, err := p.Sign(canonicaljson.CanonicalJSONAssumeValid(objJSON))
	if err != nil {
		return "", err
	}
	return string(signature), nil
}

// lastError returns the last error that happened in relation to this
// [PKSigning] object.
func (p *PKSigning) lastError() error {
	return convertError(( /*line :143:22*/_Cfunc_GoString /*line :143:31*/)(func() *_Ctype_char{ _cgo0 := /*line :143:61*/(*_Ctype_OlmPkSigning /*line :143:77*/)(p.int); _cgoCheckPointer(_cgo0, nil); return /*line :143:86*/_Cfunc_olm_pk_signing_last_error(_cgo0); }()))
}

type PKDecryption struct {
	int       * /*line :147:13*/_Ctype_OlmPkDecryption /*line :147:30*/
	mem       []byte
	publicKey []byte
}

func pkDecryptionSize() uint {
	return uint(( /*line :153:14*/_Cfunc_olm_pk_decryption_size /*line :153:37*/)())
}

func pkDecryptionPublicKeySize() uint {
	return uint(( /*line :157:14*/_Cfunc_olm_pk_key_length /*line :157:32*/)())
}

func NewPkDecryption(privateKey []byte) (*PKDecryption, error) {
	memory := make([]byte, pkDecryptionSize())
	p := &PKDecryption{
		int: func() *_Ctype_struct_OlmPkDecryption{ _cgo0 := /*line :163:28*/unsafe.Pointer(unsafe.SliceData(memory)); _cgoCheckPointer(_cgo0, nil); return /*line :163:69*/_Cfunc_olm_pk_decryption(_cgo0); }(),
		mem: memory,
	}
	p.clear()
	pubKey := make([]byte, pkDecryptionPublicKeySize())

	r := func() _Ctype_size_t{ _cgo0 := /*line :170:3*/(*_Ctype_OlmPkDecryption /*line :170:22*/)(p.int); _cgo1 := /*line :171:3*/unsafe.Pointer(unsafe.SliceData(pubKey)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :172:11*/(len(pubKey)); _cgo3 := /*line :173:3*/unsafe.Pointer(unsafe.SliceData(privateKey)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :174:11*/(len(privateKey)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); return /*line :175:3*/_Cfunc_olm_pk_key_from_private(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	runtime.KeepAlive(privateKey)
	if r == errorVal() {
		return nil, p.lastError()
	}
	p.publicKey = pubKey

	return p, nil
}

func (p *PKDecryption) PublicKey() id.Curve25519 {
	return id.Curve25519(p.publicKey)
}

func (p *PKDecryption) Decrypt(ephemeralKey []byte, mac []byte, ciphertext []byte) ([]byte, error) {
	maxPlaintextLength := uint(func() _Ctype_size_t{ _cgo0 := /*line :191:3*/(*_Ctype_OlmPkDecryption /*line :191:22*/)(p.int); var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :192:11*/(len(ciphertext)); _cgoCheckPointer(_cgo0, nil); return /*line :193:3*/_Cfunc_olm_pk_max_plaintext_length(_cgo0, _cgo1); }())
	plaintext := make([]byte, maxPlaintextLength)

	size := func() _Ctype_size_t{ _cgo0 := /*line :197:3*/(*_Ctype_OlmPkDecryption /*line :197:22*/)(p.int); _cgo1 := /*line :198:3*/unsafe.Pointer(unsafe.SliceData(ephemeralKey)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :199:11*/(len(ephemeralKey)); _cgo3 := /*line :200:3*/unsafe.Pointer(unsafe.SliceData(mac)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :201:11*/(len(mac)); _cgo5 := /*line :202:3*/unsafe.Pointer(unsafe.SliceData(ciphertext)); var _cgo6 _Ctype_size_t = _Ctype_size_t /*line :203:11*/(len(ciphertext)); _cgo7 := /*line :204:3*/unsafe.Pointer(unsafe.SliceData(plaintext)); var _cgo8 _Ctype_size_t = _Ctype_size_t /*line :205:11*/(len(plaintext)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); _cgoCheckPointer(_cgo5, nil); _cgoCheckPointer(_cgo7, nil); return /*line :206:3*/_Cfunc_olm_pk_decrypt(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7, _cgo8); }()
	runtime.KeepAlive(ephemeralKey)
	runtime.KeepAlive(mac)
	runtime.KeepAlive(ciphertext)
	if size == errorVal() {
		return nil, p.lastError()
	}

	return plaintext[:size], nil
}

// Clear clears the underlying memory of a PkDecryption object.
func (p *PKDecryption) clear() {
	func() _Ctype_size_t{ _cgo0 := /*line :219:28*/(*_Ctype_OlmPkDecryption /*line :219:47*/)(p.int); _cgoCheckPointer(_cgo0, nil); return /*line :219:56*/_Cfunc_olm_clear_pk_decryption(_cgo0); }()
}

// lastError returns the last error that happened in relation to this
// [PKDecryption] object.
func (p *PKDecryption) lastError() error {
	return convertError(( /*line :225:22*/_Cfunc_GoString /*line :225:31*/)(func() *_Ctype_char{ _cgo0 := /*line :225:64*/(*_Ctype_OlmPkDecryption /*line :225:83*/)(p.int); _cgoCheckPointer(_cgo0, nil); return /*line :225:92*/_Cfunc_olm_pk_decryption_last_error(_cgo0); }()))
}
