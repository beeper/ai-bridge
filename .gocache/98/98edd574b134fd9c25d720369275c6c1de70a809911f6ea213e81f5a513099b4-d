// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/joshpa8c/Documents/Dev/beepAI/third_party/mautrix/crypto/libolm/session.go:1:1
// Copyright (c) 2024 Sumner Evans
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

package libolm

// #cgo LDFLAGS: -lolm -lstdc++
// #include <olm/olm.h>
// #include <stdlib.h>
// #include <stdio.h>
// void olm_session_describe(OlmSession * session, char *buf, size_t buflen) __attribute__((weak));
// void meowlm_session_describe(OlmSession * session, char *buf, size_t buflen) {
//   if (olm_session_describe) {
//     olm_session_describe(session, buf, buflen);
//   } else {
//     sprintf(buf, "olm_session_describe not supported");
//   }
// }
import _ "unsafe"

import (
	"crypto/rand"
	"encoding/base64"
	"runtime"
	"unsafe"

	"maunium.net/go/mautrix/crypto/olm"
	"maunium.net/go/mautrix/id"
)

// Session stores an end to end encrypted messaging session.
type Session struct {
	int * /*line :35:7*/_Ctype_OlmSession /*line :35:19*/
	mem []byte
}

// Ensure that [Session] implements [olm.Session].
var _ olm.Session = (*Session)(nil)

// sessionSize is the size of a session object in bytes.
func sessionSize() uint {
	return uint(( /*line :44:14*/_Cfunc_olm_session_size /*line :44:31*/)())
}

// SessionFromPickled loads a Session from a pickled base64 string.  Decrypts
// the Session using the supplied key.  Returns error on failure.  If the key
// doesn't match the one used to encrypt the Session then the error will be
// "BAD_SESSION_KEY".  If the base64 couldn't be decoded then the error will be
// "INVALID_BASE64".
func SessionFromPickled(pickled, key []byte) (*Session, error) {
	if len(pickled) == 0 {
		return nil, olm.EmptyInput
	}
	s := NewBlankSession()
	return s, s.Unpickle(pickled, key)
}

func NewBlankSession() *Session {
	memory := make([]byte, sessionSize())
	return &Session{
		int: func() *_Ctype_struct_OlmSession{ _cgo0 := /*line :63:22*/unsafe.Pointer(unsafe.SliceData(memory)); _cgoCheckPointer(_cgo0, nil); return /*line :63:63*/_Cfunc_olm_session(_cgo0); }(),
		mem: memory,
	}
}

// lastError returns an error describing the most recent error to happen to a
// session.
func (s *Session) lastError() error {
	return convertError(( /*line :71:22*/_Cfunc_GoString /*line :71:31*/)(func() *_Ctype_char{ _cgo0 := /*line :71:58*/(*_Ctype_OlmSession /*line :71:72*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :71:81*/_Cfunc_olm_session_last_error(_cgo0); }()))
}

// Clear clears the memory used to back this Session.
func (s *Session) Clear() error {
	r := func() _Ctype_size_t{ _cgo0 := /*line :76:27*/(*_Ctype_OlmSession /*line :76:41*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :76:50*/_Cfunc_olm_clear_session(_cgo0); }()
	if r == errorVal() {
		return s.lastError()
	}
	return nil
}

// pickleLen returns the number of bytes needed to store a session.
func (s *Session) pickleLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :85:42*/(*_Ctype_OlmSession /*line :85:56*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :85:65*/_Cfunc_olm_pickle_session_length(_cgo0); }())
}

// createOutboundRandomLen returns the number of random bytes needed to create
// an outbound session.
func (s *Session) createOutboundRandomLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :91:58*/(*_Ctype_OlmSession /*line :91:72*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :91:81*/_Cfunc_olm_create_outbound_session_random_length(_cgo0); }())
}

// idLen returns the length of the buffer needed to return the id for this
// session.
func (s *Session) idLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :97:38*/(*_Ctype_OlmSession /*line :97:52*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :97:61*/_Cfunc_olm_session_id_length(_cgo0); }())
}

// encryptRandomLen returns the number of random bytes needed to encrypt the
// next message.
func (s *Session) encryptRandomLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :103:42*/(*_Ctype_OlmSession /*line :103:56*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :103:65*/_Cfunc_olm_encrypt_random_length(_cgo0); }())
}

// encryptMsgLen returns the size of the next message in bytes for the given
// number of plain-text bytes.
func (s *Session) encryptMsgLen(plainTextLen int) uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :109:43*/(*_Ctype_OlmSession /*line :109:57*/)(s.int); var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :109:75*/(plainTextLen); _cgoCheckPointer(_cgo0, nil); return /*line :109:90*/_Cfunc_olm_encrypt_message_length(_cgo0, _cgo1); }())
}

// decryptMaxPlaintextLen returns the maximum number of bytes of plain-text a
// given message could decode to.  The actual size could be different due to
// padding.  Returns error on failure.  If the message base64 couldn't be
// decoded then the error will be "INVALID_BASE64".  If the message is for an
// unsupported version of the protocol then the error will be
// "BAD_MESSAGE_VERSION".  If the message couldn't be decoded then the error
// will be "BAD_MESSAGE_FORMAT".
func (s *Session) decryptMaxPlaintextLen(message string, msgType id.OlmMsgType) (uint, error) {
	if len(message) == 0 {
		return 0, olm.EmptyInput
	}
	messageCopy := []byte(message)
	r := func() _Ctype_size_t{ _cgo0 := /*line :125:3*/(*_Ctype_OlmSession /*line :125:17*/)(s.int); var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :126:11*/(msgType); _cgo2 := /*line :127:3*/unsafe.Pointer(unsafe.SliceData((messageCopy))); var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :128:11*/(len(messageCopy)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :129:3*/_Cfunc_olm_decrypt_max_plaintext_length(_cgo0, _cgo1, _cgo2, _cgo3); }()
	runtime.KeepAlive(messageCopy)
	if r == errorVal() {
		return 0, s.lastError()
	}
	return uint(r), nil
}

// Pickle returns a Session as a base64 string.  Encrypts the Session using the
// supplied key.
func (s *Session) Pickle(key []byte) ([]byte, error) {
	if len(key) == 0 {
		return nil, olm.NoKeyProvided
	}
	pickled := make([]byte, s.pickleLen())
	r := func() _Ctype_size_t{ _cgo0 := /*line :145:3*/(*_Ctype_OlmSession /*line :145:17*/)(s.int); _cgo1 := /*line :146:3*/unsafe.Pointer(unsafe.SliceData(key)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :147:11*/(len(key)); _cgo3 := /*line :148:3*/unsafe.Pointer(unsafe.SliceData(pickled)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :149:11*/(len(pickled)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); return /*line :149:26*/_Cfunc_olm_pickle_session(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	runtime.KeepAlive(key)
	if r == errorVal() {
		panic(s.lastError())
	}
	return pickled[:r], nil
}

// Unpickle unpickles the base64-encoded Olm session decrypting it with the
// provided key. This function mutates the input pickled data slice.
func (s *Session) Unpickle(pickled, key []byte) error {
	if len(key) == 0 {
		return olm.NoKeyProvided
	}
	r := func() _Ctype_size_t{ _cgo0 := /*line :164:3*/(*_Ctype_OlmSession /*line :164:17*/)(s.int); _cgo1 := /*line :165:3*/unsafe.Pointer(unsafe.SliceData(key)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :166:11*/(len(key)); _cgo3 := /*line :167:3*/unsafe.Pointer(unsafe.SliceData(pickled)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :168:11*/(len(pickled)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); return /*line :168:26*/_Cfunc_olm_unpickle_session(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	runtime.KeepAlive(pickled)
	runtime.KeepAlive(key)
	if r == errorVal() {
		return s.lastError()
	}
	return nil
}

// Deprecated
func (s *Session) GobEncode() ([]byte, error) {
	pickled, err := s.Pickle(pickleKey)
	if err != nil {
		return nil, err
	}
	length := base64.RawStdEncoding.DecodedLen(len(pickled))
	rawPickled := make([]byte, length)
	_, err = base64.RawStdEncoding.Decode(rawPickled, pickled)
	return rawPickled, err
}

// Deprecated
func (s *Session) GobDecode(rawPickled []byte) error {
	if s == nil || s.int == nil {
		*s = *NewBlankSession()
	}
	length := base64.RawStdEncoding.EncodedLen(len(rawPickled))
	pickled := make([]byte, length)
	base64.RawStdEncoding.Encode(pickled, rawPickled)
	return s.Unpickle(pickled, pickleKey)
}

// Deprecated
func (s *Session) MarshalJSON() ([]byte, error) {
	pickled, err := s.Pickle(pickleKey)
	if err != nil {
		return nil, err
	}
	quotes := make([]byte, len(pickled)+2)
	quotes[0] = '"'
	quotes[len(quotes)-1] = '"'
	copy(quotes[1:len(quotes)-1], pickled)
	return quotes, nil
}

// Deprecated
func (s *Session) UnmarshalJSON(data []byte) error {
	if len(data) == 0 || data[0] != '"' || data[len(data)-1] != '"' {
		return olm.InputNotJSONString
	}
	if s == nil || s.int == nil {
		*s = *NewBlankSession()
	}
	return s.Unpickle(data[1:len(data)-1], pickleKey)
}

// Id returns an identifier for this Session.  Will be the same for both ends
// of the conversation.
func (s *Session) ID() id.SessionID {
	sessionID := make([]byte, s.idLen())
	r := func() _Ctype_size_t{ _cgo0 := /*line :229:3*/(*_Ctype_OlmSession /*line :229:17*/)(s.int); _cgo1 := /*line :230:3*/unsafe.Pointer(unsafe.SliceData(sessionID)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :231:11*/(len(sessionID)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :232:3*/_Cfunc_olm_session_id(_cgo0, _cgo1, _cgo2); }()
	if r == errorVal() {
		panic(s.lastError())
	}
	return id.SessionID(sessionID)
}

// HasReceivedMessage returns true if this session has received any message.
func (s *Session) HasReceivedMessage() bool {
	switch func() _Ctype_int{ _cgo0 := /*line :241:44*/(*_Ctype_OlmSession /*line :241:58*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :241:67*/_Cfunc_olm_session_has_received_message(_cgo0); }() {
	case 0:
		return false
	default:
		return true
	}
}

// MatchesInboundSession checks if the PRE_KEY message is for this in-bound
// Session.  This can happen if multiple messages are sent to this Account
// before this Account sends a message in reply.  Returns true if the session
// matches.  Returns false if the session does not match.  Returns error on
// failure.  If the base64 couldn't be decoded then the error will be
// "INVALID_BASE64".  If the message was for an unsupported protocol version
// then the error will be "BAD_MESSAGE_VERSION".  If the message couldn't be
// decoded then then the error will be "BAD_MESSAGE_FORMAT".
func (s *Session) MatchesInboundSession(oneTimeKeyMsg string) (bool, error) {
	if len(oneTimeKeyMsg) == 0 {
		return false, olm.EmptyInput
	}
	oneTimeKeyMsgCopy := []byte(oneTimeKeyMsg)
	r := func() _Ctype_size_t{ _cgo0 := /*line :263:3*/(*_Ctype_OlmSession /*line :263:17*/)(s.int); _cgo1 := /*line :264:3*/unsafe.Pointer(unsafe.SliceData(oneTimeKeyMsgCopy)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :265:11*/(len(oneTimeKeyMsgCopy)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :266:3*/_Cfunc_olm_matches_inbound_session(_cgo0, _cgo1, _cgo2); }()
	runtime.KeepAlive(oneTimeKeyMsgCopy)
	if r == 1 {
		return true, nil
	} else if r == 0 {
		return false, nil
	} else { // if r == errorVal()
		return false, s.lastError()
	}
}

// MatchesInboundSessionFrom checks if the PRE_KEY message is for this in-bound
// Session.  This can happen if multiple messages are sent to this Account
// before this Account sends a message in reply.  Returns true if the session
// matches.  Returns false if the session does not match.  Returns error on
// failure.  If the base64 couldn't be decoded then the error will be
// "INVALID_BASE64".  If the message was for an unsupported protocol version
// then the error will be "BAD_MESSAGE_VERSION".  If the message couldn't be
// decoded then then the error will be "BAD_MESSAGE_FORMAT".
func (s *Session) MatchesInboundSessionFrom(theirIdentityKey, oneTimeKeyMsg string) (bool, error) {
	if len(theirIdentityKey) == 0 || len(oneTimeKeyMsg) == 0 {
		return false, olm.EmptyInput
	}
	theirIdentityKeyCopy := []byte(theirIdentityKey)
	oneTimeKeyMsgCopy := []byte(oneTimeKeyMsg)
	r := func() _Ctype_size_t{ _cgo0 := /*line :292:3*/(*_Ctype_OlmSession /*line :292:17*/)(s.int); _cgo1 := /*line :293:3*/unsafe.Pointer(unsafe.SliceData(theirIdentityKeyCopy)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :294:11*/(len(theirIdentityKeyCopy)); _cgo3 := /*line :295:3*/unsafe.Pointer(unsafe.SliceData(oneTimeKeyMsgCopy)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :296:11*/(len(oneTimeKeyMsgCopy)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); return /*line :297:3*/_Cfunc_olm_matches_inbound_session_from(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	runtime.KeepAlive(theirIdentityKeyCopy)
	runtime.KeepAlive(oneTimeKeyMsgCopy)
	if r == 1 {
		return true, nil
	} else if r == 0 {
		return false, nil
	} else { // if r == errorVal()
		return false, s.lastError()
	}
}

// EncryptMsgType returns the type of the next message that Encrypt will
// return.  Returns MsgTypePreKey if the message will be a PRE_KEY message.
// Returns MsgTypeMsg if the message will be a normal message.  Returns error
// on failure.
func (s *Session) EncryptMsgType() id.OlmMsgType {
	switch func() _Ctype_size_t{ _cgo0 := /*line :314:36*/(*_Ctype_OlmSession /*line :314:50*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :314:59*/_Cfunc_olm_encrypt_message_type(_cgo0); }() {
	case  /*line :315:7*/_Ctype_size_t /*line :315:15*/(id.OlmMsgTypePreKey):
		return id.OlmMsgTypePreKey
	case  /*line :317:7*/_Ctype_size_t /*line :317:15*/(id.OlmMsgTypeMsg):
		return id.OlmMsgTypeMsg
	default:
		panic("olm_encrypt_message_type returned invalid result")
	}
}

// Encrypt encrypts a message using the Session.  Returns the encrypted message
// as base64.
func (s *Session) Encrypt(plaintext []byte) (id.OlmMsgType, []byte, error) {
	if len(plaintext) == 0 {
		return 0, nil, olm.EmptyInput
	}
	// Make the slice be at least length 1
	random := make([]byte, s.encryptRandomLen()+1)
	_, err := rand.Read(random)
	if err != nil {
		// TODO can we just return err here?
		return 0, nil, olm.NotEnoughGoRandom
	}
	messageType := s.EncryptMsgType()
	message := make([]byte, s.encryptMsgLen(len(plaintext)))
	r := func() _Ctype_size_t{ _cgo0 := /*line :340:3*/(*_Ctype_OlmSession /*line :340:17*/)(s.int); _cgo1 := /*line :341:3*/unsafe.Pointer(unsafe.SliceData(plaintext)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :342:11*/(len(plaintext)); _cgo3 := /*line :343:3*/unsafe.Pointer(unsafe.SliceData(random)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :344:11*/(len(random)); _cgo5 := /*line :345:3*/unsafe.Pointer(unsafe.SliceData(message)); var _cgo6 _Ctype_size_t = _Ctype_size_t /*line :346:11*/(len(message)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); _cgoCheckPointer(_cgo5, nil); return /*line :347:3*/_Cfunc_olm_encrypt(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
	runtime.KeepAlive(plaintext)
	runtime.KeepAlive(random)
	if r == errorVal() {
		return 0, nil, s.lastError()
	}
	return messageType, message[:r], nil
}

// Decrypt decrypts a message using the Session.  Returns the the plain-text on
// success.  Returns error on failure.  If the base64 couldn't be decoded then
// the error will be "INVALID_BASE64".  If the message is for an unsupported
// version of the protocol then the error will be "BAD_MESSAGE_VERSION".  If
// the message couldn't be decoded then the error will be BAD_MESSAGE_FORMAT".
// If the MAC on the message was invalid then the error will be
// "BAD_MESSAGE_MAC".
func (s *Session) Decrypt(message string, msgType id.OlmMsgType) ([]byte, error) {
	if len(message) == 0 {
		return nil, olm.EmptyInput
	}
	decryptMaxPlaintextLen, err := s.decryptMaxPlaintextLen(message, msgType)
	if err != nil {
		return nil, err
	}
	messageCopy := []byte(message)
	plaintext := make([]byte, decryptMaxPlaintextLen)
	r := func() _Ctype_size_t{ _cgo0 := /*line :374:3*/(*_Ctype_OlmSession /*line :374:17*/)(s.int); var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :375:11*/(msgType); _cgo2 := /*line :376:3*/unsafe.Pointer(unsafe.SliceData(messageCopy)); var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :377:11*/(len(messageCopy)); _cgo4 := /*line :378:3*/unsafe.Pointer(unsafe.SliceData(plaintext)); var _cgo5 _Ctype_size_t = _Ctype_size_t /*line :379:11*/(len(plaintext)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo4, nil); return /*line :380:3*/_Cfunc_olm_decrypt(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	runtime.KeepAlive(messageCopy)
	if r == errorVal() {
		return nil, s.lastError()
	}
	return plaintext[:r], nil
}

// https://gitlab.matrix.org/matrix-org/olm/-/blob/3.2.8/include/olm/olm.h#L392-393
const maxDescribeSize = 600

// Describe generates a string describing the internal state of an olm session for debugging and logging purposes.
func (s *Session) Describe() string {
	desc := (* /*line :393:12*/_Ctype_char /*line :393:18*/)(( /*line :393:20*/_Cfunc__CMalloc /*line :393:27*/)( /*line :393:29*/_Ctype_size_t /*line :393:37*/(maxDescribeSize)))
	defer func() func() { _cgo0 := /*line :394:15*/unsafe.Pointer(desc); return func() { _cgoCheckPointer(_cgo0, nil); /*line :394:36*/_Cfunc_free(_cgo0); }}()()
	func() { _cgo0 := /*line :396:3*/(*_Ctype_OlmSession /*line :396:17*/)(s.int); var _cgo1 *_Ctype_char = /*line :397:3*/desc; var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :398:11*/(maxDescribeSize); _cgoCheckPointer(_cgo0, nil); /*line :399:3*/_Cfunc_meowlm_session_describe(_cgo0, _cgo1, _cgo2); }()
	return ( /*line :400:9*/_Cfunc_GoString /*line :400:18*/)(desc)
}
