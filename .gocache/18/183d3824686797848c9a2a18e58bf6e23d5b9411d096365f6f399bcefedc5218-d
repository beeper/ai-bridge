// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/joshpa8c/Documents/Dev/beepAI/third_party/mautrix/crypto/libolm/account.go:1:1
package libolm

// #cgo LDFLAGS: -lolm -lstdc++
// #include <olm/olm.h>
import _ "unsafe"

import (
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"runtime"
	"unsafe"

	"github.com/tidwall/gjson"

	"maunium.net/go/mautrix/crypto/olm"
	"maunium.net/go/mautrix/id"
)

// Account stores a device account for end to end encrypted messaging.
type Account struct {
	int * /*line :22:7*/_Ctype_OlmAccount /*line :22:19*/
	mem []byte
}

// Ensure that [Account] implements [olm.Account].
var _ olm.Account = (*Account)(nil)

// AccountFromPickled loads an Account from a pickled base64 string.  Decrypts
// the Account using the supplied key.  Returns error on failure.  If the key
// doesn't match the one used to encrypt the Account then the error will be
// "BAD_ACCOUNT_KEY".  If the base64 couldn't be decoded then the error will be
// "INVALID_BASE64".
func AccountFromPickled(pickled, key []byte) (*Account, error) {
	if len(pickled) == 0 {
		return nil, olm.EmptyInput
	}
	a := NewBlankAccount()
	return a, a.Unpickle(pickled, key)
}

func NewBlankAccount() *Account {
	memory := make([]byte, accountSize())
	return &Account{
		int: func() *_Ctype_struct_OlmAccount{ _cgo0 := /*line :45:22*/unsafe.Pointer(unsafe.SliceData(memory)); _cgoCheckPointer(_cgo0, nil); return /*line :45:63*/_Cfunc_olm_account(_cgo0); }(),
		mem: memory,
	}
}

// NewAccount creates a new [Account].
func NewAccount() (*Account, error) {
	a := NewBlankAccount()
	random := make([]byte, a.createRandomLen()+1)
	_, err := rand.Read(random)
	if err != nil {
		panic(olm.NotEnoughGoRandom)
	}
	ret := func() _Ctype_size_t{ _cgo0 := /*line :59:3*/(*_Ctype_OlmAccount /*line :59:17*/)(a.int); _cgo1 := /*line :60:3*/unsafe.Pointer(unsafe.SliceData(random)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :61:11*/(len(random)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :61:25*/_Cfunc_olm_create_account(_cgo0, _cgo1, _cgo2); }()
	runtime.KeepAlive(random)
	if ret == errorVal() {
		return nil, a.lastError()
	} else {
		return a, nil
	}
}

// accountSize returns the size of an account object in bytes.
func accountSize() uint {
	return uint(( /*line :72:14*/_Cfunc_olm_account_size /*line :72:31*/)())
}

// lastError returns an error describing the most recent error to happen to an
// account.
func (a *Account) lastError() error {
	return convertError(( /*line :78:22*/_Cfunc_GoString /*line :78:31*/)(func() *_Ctype_char{ _cgo0 := /*line :78:58*/(*_Ctype_OlmAccount /*line :78:72*/)(a.int); _cgoCheckPointer(_cgo0, nil); return /*line :78:81*/_Cfunc_olm_account_last_error(_cgo0); }()))
}

// Clear clears the memory used to back this Account.
func (a *Account) Clear() error {
	r := func() _Ctype_size_t{ _cgo0 := /*line :83:27*/(*_Ctype_OlmAccount /*line :83:41*/)(a.int); _cgoCheckPointer(_cgo0, nil); return /*line :83:50*/_Cfunc_olm_clear_account(_cgo0); }()
	if r == errorVal() {
		return a.lastError()
	} else {
		return nil
	}
}

// pickleLen returns the number of bytes needed to store an Account.
func (a *Account) pickleLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :93:42*/(*_Ctype_OlmAccount /*line :93:56*/)(a.int); _cgoCheckPointer(_cgo0, nil); return /*line :93:65*/_Cfunc_olm_pickle_account_length(_cgo0); }())
}

// createRandomLen returns the number of random bytes needed to create an
// Account.
func (a *Account) createRandomLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :99:49*/(*_Ctype_OlmAccount /*line :99:63*/)(a.int); _cgoCheckPointer(_cgo0, nil); return /*line :99:72*/_Cfunc_olm_create_account_random_length(_cgo0); }())
}

// identityKeysLen returns the size of the output buffer needed to hold the
// identity keys.
func (a *Account) identityKeysLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :105:49*/(*_Ctype_OlmAccount /*line :105:63*/)(a.int); _cgoCheckPointer(_cgo0, nil); return /*line :105:72*/_Cfunc_olm_account_identity_keys_length(_cgo0); }())
}

// signatureLen returns the length of an ed25519 signature encoded as base64.
func (a *Account) signatureLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :110:45*/(*_Ctype_OlmAccount /*line :110:59*/)(a.int); _cgoCheckPointer(_cgo0, nil); return /*line :110:68*/_Cfunc_olm_account_signature_length(_cgo0); }())
}

// oneTimeKeysLen returns the size of the output buffer needed to hold the one
// time keys.
func (a *Account) oneTimeKeysLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :116:49*/(*_Ctype_OlmAccount /*line :116:63*/)(a.int); _cgoCheckPointer(_cgo0, nil); return /*line :116:72*/_Cfunc_olm_account_one_time_keys_length(_cgo0); }())
}

// genOneTimeKeysRandomLen returns the number of random bytes needed to
// generate a given number of new one time keys.
func (a *Account) genOneTimeKeysRandomLen(num uint) uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :123:3*/(*_Ctype_OlmAccount /*line :123:17*/)(a.int); var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :124:11*/(num); _cgoCheckPointer(_cgo0, nil); return /*line :124:17*/_Cfunc_olm_account_generate_one_time_keys_random_length(_cgo0, _cgo1); }())
}

// Pickle returns an Account as a base64 string. Encrypts the Account using the
// supplied key.
func (a *Account) Pickle(key []byte) ([]byte, error) {
	if len(key) == 0 {
		return nil, olm.NoKeyProvided
	}
	pickled := make([]byte, a.pickleLen())
	r := func() _Ctype_size_t{ _cgo0 := /*line :135:3*/(*_Ctype_OlmAccount /*line :135:17*/)(a.int); _cgo1 := /*line :136:3*/unsafe.Pointer(unsafe.SliceData(key)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :137:11*/(len(key)); _cgo3 := /*line :138:3*/unsafe.Pointer(unsafe.SliceData(pickled)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :139:11*/(len(pickled)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); return /*line :139:26*/_Cfunc_olm_pickle_account(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	if r == errorVal() {
		return nil, a.lastError()
	}
	return pickled[:r], nil
}

func (a *Account) Unpickle(pickled, key []byte) error {
	if len(key) == 0 {
		return olm.NoKeyProvided
	}
	r := func() _Ctype_size_t{ _cgo0 := /*line :151:3*/(*_Ctype_OlmAccount /*line :151:17*/)(a.int); _cgo1 := /*line :152:3*/unsafe.Pointer(unsafe.SliceData(key)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :153:11*/(len(key)); _cgo3 := /*line :154:3*/unsafe.Pointer(unsafe.SliceData(pickled)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :155:11*/(len(pickled)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); return /*line :155:26*/_Cfunc_olm_unpickle_account(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	if r == errorVal() {
		return a.lastError()
	}
	return nil
}

// Deprecated
func (a *Account) GobEncode() ([]byte, error) {
	pickled, err := a.Pickle(pickleKey)
	if err != nil {
		return nil, err
	}
	length := base64.RawStdEncoding.DecodedLen(len(pickled))
	rawPickled := make([]byte, length)
	_, err = base64.RawStdEncoding.Decode(rawPickled, pickled)
	return rawPickled, err
}

// Deprecated
func (a *Account) GobDecode(rawPickled []byte) error {
	if a.int == nil {
		*a = *NewBlankAccount()
	}
	length := base64.RawStdEncoding.EncodedLen(len(rawPickled))
	pickled := make([]byte, length)
	base64.RawStdEncoding.Encode(pickled, rawPickled)
	return a.Unpickle(pickled, pickleKey)
}

// Deprecated
func (a *Account) MarshalJSON() ([]byte, error) {
	pickled, err := a.Pickle(pickleKey)
	if err != nil {
		return nil, err
	}
	quotes := make([]byte, len(pickled)+2)
	quotes[0] = '"'
	quotes[len(quotes)-1] = '"'
	copy(quotes[1:len(quotes)-1], pickled)
	return quotes, nil
}

// Deprecated
func (a *Account) UnmarshalJSON(data []byte) error {
	if len(data) == 0 || data[0] != '"' || data[len(data)-1] != '"' {
		return olm.InputNotJSONString
	}
	if a.int == nil {
		*a = *NewBlankAccount()
	}
	return a.Unpickle(data[1:len(data)-1], pickleKey)
}

// IdentityKeysJSON returns the public parts of the identity keys for the Account.
func (a *Account) IdentityKeysJSON() ([]byte, error) {
	identityKeys := make([]byte, a.identityKeysLen())
	r := func() _Ctype_size_t{ _cgo0 := /*line :213:3*/(*_Ctype_OlmAccount /*line :213:17*/)(a.int); _cgo1 := /*line :214:3*/unsafe.Pointer(unsafe.SliceData(identityKeys)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :215:11*/(len(identityKeys)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :215:31*/_Cfunc_olm_account_identity_keys(_cgo0, _cgo1, _cgo2); }()
	if r == errorVal() {
		return nil, a.lastError()
	} else {
		return identityKeys, nil
	}
}

// IdentityKeys returns the public parts of the Ed25519 and Curve25519 identity
// keys for the Account.
func (a *Account) IdentityKeys() (id.Ed25519, id.Curve25519, error) {
	identityKeysJSON, err := a.IdentityKeysJSON()
	if err != nil {
		return "", "", err
	}
	results := gjson.GetManyBytes(identityKeysJSON, "ed25519", "curve25519")
	return id.Ed25519(results[0].Str), id.Curve25519(results[1].Str), nil
}

// Sign returns the signature of a message using the ed25519 key for this
// Account.
func (a *Account) Sign(message []byte) ([]byte, error) {
	if len(message) == 0 {
		panic(olm.EmptyInput)
	}
	signature := make([]byte, a.signatureLen())
	r := func() _Ctype_size_t{ _cgo0 := /*line :242:3*/(*_Ctype_OlmAccount /*line :242:17*/)(a.int); _cgo1 := /*line :243:3*/unsafe.Pointer(unsafe.SliceData(message)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :244:11*/(len(message)); _cgo3 := /*line :245:3*/unsafe.Pointer(unsafe.SliceData(signature)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :246:11*/(len(signature)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); return /*line :246:28*/_Cfunc_olm_account_sign(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	runtime.KeepAlive(message)
	if r == errorVal() {
		panic(a.lastError())
	}
	return signature, nil
}

// OneTimeKeys returns the public parts of the unpublished one time keys for
// the Account.
//
// The returned data is a struct with the single value "Curve25519", which is
// itself an object mapping key id to base64-encoded Curve25519 key.  For
// example:
//
//	{
//	    Curve25519: {
//	        "AAAAAA": "wo76WcYtb0Vk/pBOdmduiGJ0wIEjW4IBMbbQn7aSnTo",
//	        "AAAAAB": "LRvjo46L1X2vx69sS9QNFD29HWulxrmW11Up5AfAjgU"
//	    }
//	}
func (a *Account) OneTimeKeys() (map[string]id.Curve25519, error) {
	oneTimeKeysJSON := make([]byte, a.oneTimeKeysLen())
	r := func() _Ctype_size_t{ _cgo0 := /*line :270:3*/(*_Ctype_OlmAccount /*line :270:17*/)(a.int); _cgo1 := /*line :271:3*/unsafe.Pointer(unsafe.SliceData(oneTimeKeysJSON)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :272:11*/(len(oneTimeKeysJSON)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :273:3*/_Cfunc_olm_account_one_time_keys(_cgo0, _cgo1, _cgo2); }()
	if r == errorVal() {
		return nil, a.lastError()
	}
	var oneTimeKeys struct {
		Curve25519 map[string]id.Curve25519 `json:"curve25519"`
	}
	return oneTimeKeys.Curve25519, json.Unmarshal(oneTimeKeysJSON, &oneTimeKeys)
}

// MarkKeysAsPublished marks the current set of one time keys as being
// published.
func (a *Account) MarkKeysAsPublished() {
	func() _Ctype_size_t{ _cgo0 := /*line :286:39*/(*_Ctype_OlmAccount /*line :286:53*/)(a.int); _cgoCheckPointer(_cgo0, nil); return /*line :286:62*/_Cfunc_olm_account_mark_keys_as_published(_cgo0); }()
}

// MaxNumberOfOneTimeKeys returns the largest number of one time keys this
// Account can store.
func (a *Account) MaxNumberOfOneTimeKeys() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :292:56*/(*_Ctype_OlmAccount /*line :292:70*/)(a.int); _cgoCheckPointer(_cgo0, nil); return /*line :292:79*/_Cfunc_olm_account_max_number_of_one_time_keys(_cgo0); }())
}

// GenOneTimeKeys generates a number of new one time keys.  If the total number
// of keys stored by this Account exceeds MaxNumberOfOneTimeKeys then the old
// keys are discarded.
func (a *Account) GenOneTimeKeys(num uint) error {
	random := make([]byte, a.genOneTimeKeysRandomLen(num)+1)
	_, err := rand.Read(random)
	if err != nil {
		return olm.NotEnoughGoRandom
	}
	r := func() _Ctype_size_t{ _cgo0 := /*line :305:3*/(*_Ctype_OlmAccount /*line :305:17*/)(a.int); var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :306:11*/(num); _cgo2 := /*line :307:3*/unsafe.Pointer(unsafe.SliceData(random)); var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :308:11*/(len(random)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :309:3*/_Cfunc_olm_account_generate_one_time_keys(_cgo0, _cgo1, _cgo2, _cgo3); }()
	runtime.KeepAlive(random)
	if r == errorVal() {
		return a.lastError()
	}
	return nil
}

// NewOutboundSession creates a new out-bound session for sending messages to a
// given curve25519 identityKey and oneTimeKey.  Returns error on failure.  If the
// keys couldn't be decoded as base64 then the error will be "INVALID_BASE64"
func (a *Account) NewOutboundSession(theirIdentityKey, theirOneTimeKey id.Curve25519) (olm.Session, error) {
	if len(theirIdentityKey) == 0 || len(theirOneTimeKey) == 0 {
		return nil, olm.EmptyInput
	}
	s := NewBlankSession()
	random := make([]byte, s.createOutboundRandomLen()+1)
	_, err := rand.Read(random)
	if err != nil {
		panic(olm.NotEnoughGoRandom)
	}
	theirIdentityKeyCopy := []byte(theirIdentityKey)
	theirOneTimeKeyCopy := []byte(theirOneTimeKey)
	r := func() _Ctype_size_t{ _cgo0 := /*line :333:3*/(*_Ctype_OlmSession /*line :333:17*/)(s.int); _cgo1 := /*line :334:3*/(*_Ctype_OlmAccount /*line :334:17*/)(a.int); _cgo2 := /*line :335:3*/unsafe.Pointer(unsafe.SliceData(theirIdentityKeyCopy)); var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :336:11*/(len(theirIdentityKeyCopy)); _cgo4 := /*line :337:3*/unsafe.Pointer(unsafe.SliceData(theirOneTimeKeyCopy)); var _cgo5 _Ctype_size_t = _Ctype_size_t /*line :338:11*/(len(theirOneTimeKeyCopy)); _cgo6 := /*line :339:3*/unsafe.Pointer(unsafe.SliceData(random)); var _cgo7 _Ctype_size_t = _Ctype_size_t /*line :340:11*/(len(random)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo4, nil); _cgoCheckPointer(_cgo6, nil); return /*line :341:3*/_Cfunc_olm_create_outbound_session(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
	runtime.KeepAlive(random)
	runtime.KeepAlive(theirIdentityKeyCopy)
	runtime.KeepAlive(theirOneTimeKeyCopy)
	if r == errorVal() {
		return nil, s.lastError()
	}
	return s, nil
}

// NewInboundSession creates a new in-bound session for sending/receiving
// messages from an incoming PRE_KEY message.  Returns error on failure.  If
// the base64 couldn't be decoded then the error will be "INVALID_BASE64".  If
// the message was for an unsupported protocol version then the error will be
// "BAD_MESSAGE_VERSION".  If the message couldn't be decoded then then the
// error will be "BAD_MESSAGE_FORMAT".  If the message refers to an unknown one
// time key then the error will be "BAD_MESSAGE_KEY_ID".
func (a *Account) NewInboundSession(oneTimeKeyMsg string) (olm.Session, error) {
	if len(oneTimeKeyMsg) == 0 {
		return nil, olm.EmptyInput
	}
	s := NewBlankSession()
	oneTimeKeyMsgCopy := []byte(oneTimeKeyMsg)
	r := func() _Ctype_size_t{ _cgo0 := /*line :365:3*/(*_Ctype_OlmSession /*line :365:17*/)(s.int); _cgo1 := /*line :366:3*/(*_Ctype_OlmAccount /*line :366:17*/)(a.int); _cgo2 := /*line :367:3*/unsafe.Pointer(unsafe.SliceData(oneTimeKeyMsgCopy)); var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :368:11*/(len(oneTimeKeyMsgCopy)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); return /*line :369:3*/_Cfunc_olm_create_inbound_session(_cgo0, _cgo1, _cgo2, _cgo3); }()
	runtime.KeepAlive(oneTimeKeyMsgCopy)
	if r == errorVal() {
		return nil, s.lastError()
	}
	return s, nil
}

// NewInboundSessionFrom creates a new in-bound session for sending/receiving
// messages from an incoming PRE_KEY message.  Returns error on failure.  If
// the base64 couldn't be decoded then the error will be "INVALID_BASE64".  If
// the message was for an unsupported protocol version then the error will be
// "BAD_MESSAGE_VERSION".  If the message couldn't be decoded then then the
// error will be "BAD_MESSAGE_FORMAT".  If the message refers to an unknown one
// time key then the error will be "BAD_MESSAGE_KEY_ID".
func (a *Account) NewInboundSessionFrom(theirIdentityKey *id.Curve25519, oneTimeKeyMsg string) (olm.Session, error) {
	if theirIdentityKey == nil || len(oneTimeKeyMsg) == 0 {
		return nil, olm.EmptyInput
	}
	theirIdentityKeyCopy := []byte(*theirIdentityKey)
	oneTimeKeyMsgCopy := []byte(oneTimeKeyMsg)
	s := NewBlankSession()
	r := func() _Ctype_size_t{ _cgo0 := /*line :392:3*/(*_Ctype_OlmSession /*line :392:17*/)(s.int); _cgo1 := /*line :393:3*/(*_Ctype_OlmAccount /*line :393:17*/)(a.int); _cgo2 := /*line :394:3*/unsafe.Pointer(unsafe.SliceData(theirIdentityKeyCopy)); var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :395:11*/(len(theirIdentityKeyCopy)); _cgo4 := /*line :396:3*/unsafe.Pointer(unsafe.SliceData(oneTimeKeyMsgCopy)); var _cgo5 _Ctype_size_t = _Ctype_size_t /*line :397:11*/(len(oneTimeKeyMsgCopy)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo4, nil); return /*line :398:3*/_Cfunc_olm_create_inbound_session_from(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	runtime.KeepAlive(theirIdentityKeyCopy)
	runtime.KeepAlive(oneTimeKeyMsgCopy)
	if r == errorVal() {
		return nil, s.lastError()
	}
	return s, nil
}

// RemoveOneTimeKeys removes the one time keys that the session used from the
// Account.  Returns error on failure.  If the Account doesn't have any
// matching one time keys then the error will be "BAD_MESSAGE_KEY_ID".
func (a *Account) RemoveOneTimeKeys(s olm.Session) error {
	r := func() _Ctype_size_t{ _cgo0 := /*line :412:3*/(*_Ctype_OlmAccount /*line :412:17*/)(a.int); _cgo1 := /*line :413:3*/(*_Ctype_OlmSession /*line :413:17*/)(s.(*Session).int); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :414:3*/_Cfunc_olm_remove_one_time_keys(_cgo0, _cgo1); }()
	if r == errorVal() {
		return a.lastError()
	}
	return nil
}
