// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/joshpa8c/Documents/Dev/beepAI/third_party/mautrix/crypto/libolm/inboundgroupsession.go:1:1
package libolm

// #cgo LDFLAGS: -lolm -lstdc++
// #include <olm/olm.h>
import _ "unsafe"

import (
	"bytes"
	"encoding/base64"
	"runtime"
	"unsafe"

	"maunium.net/go/mautrix/crypto/olm"
	"maunium.net/go/mautrix/id"
)

// InboundGroupSession stores an inbound encrypted messaging session for a
// group.
type InboundGroupSession struct {
	int * /*line :20:7*/_Ctype_OlmInboundGroupSession /*line :20:31*/
	mem []byte
}

// Ensure that [InboundGroupSession] implements [olm.InboundGroupSession].
var _ olm.InboundGroupSession = (*InboundGroupSession)(nil)

// InboundGroupSessionFromPickled loads an InboundGroupSession from a pickled
// base64 string.  Decrypts the InboundGroupSession using the supplied key.
// Returns error on failure.  If the key doesn't match the one used to encrypt
// the InboundGroupSession then the error will be "BAD_SESSION_KEY".  If the
// base64 couldn't be decoded then the error will be "INVALID_BASE64".
func InboundGroupSessionFromPickled(pickled, key []byte) (*InboundGroupSession, error) {
	if len(pickled) == 0 {
		return nil, olm.EmptyInput
	}
	lenKey := len(key)
	if lenKey == 0 {
		key = []byte(" ")
	}
	s := NewBlankInboundGroupSession()
	return s, s.Unpickle(pickled, key)
}

// NewInboundGroupSession creates a new inbound group session from a key
// exported from OutboundGroupSession.Key().  Returns error on failure.
// If the sessionKey is not valid base64 the error will be
// "OLM_INVALID_BASE64".  If the session_key is invalid the error will be
// "OLM_BAD_SESSION_KEY".
func NewInboundGroupSession(sessionKey []byte) (*InboundGroupSession, error) {
	if len(sessionKey) == 0 {
		return nil, olm.EmptyInput
	}
	s := NewBlankInboundGroupSession()
	r := func() _Ctype_size_t{ _cgo0 := /*line :55:3*/(*_Ctype_OlmInboundGroupSession /*line :55:29*/)(s.int); var _cgo1 *_Ctype_uint8_t = /*line :56:3*/(*_Ctype_uint8_t /*line :56:14*/)(unsafe.Pointer(unsafe.SliceData(sessionKey))); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :57:11*/(len(sessionKey)); _cgoCheckPointer(_cgo0, nil); return /*line :58:3*/_Cfunc_olm_init_inbound_group_session(_cgo0, _cgo1, _cgo2); }()
	runtime.KeepAlive(sessionKey)
	if r == errorVal() {
		return nil, s.lastError()
	}
	return s, nil
}

// InboundGroupSessionImport imports an inbound group session from a previous
// export.  Returns error on failure.  If the sessionKey is not valid base64
// the error will be "OLM_INVALID_BASE64".  If the session_key is invalid the
// error will be "OLM_BAD_SESSION_KEY".
func InboundGroupSessionImport(sessionKey []byte) (*InboundGroupSession, error) {
	if len(sessionKey) == 0 {
		return nil, olm.EmptyInput
	}
	s := NewBlankInboundGroupSession()
	r := func() _Ctype_size_t{ _cgo0 := /*line :76:3*/(*_Ctype_OlmInboundGroupSession /*line :76:29*/)(s.int); var _cgo1 *_Ctype_uint8_t = /*line :77:3*/(*_Ctype_uint8_t /*line :77:14*/)(unsafe.Pointer(unsafe.SliceData(sessionKey))); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :78:11*/(len(sessionKey)); _cgoCheckPointer(_cgo0, nil); return /*line :79:3*/_Cfunc_olm_import_inbound_group_session(_cgo0, _cgo1, _cgo2); }()
	runtime.KeepAlive(sessionKey)
	if r == errorVal() {
		return nil, s.lastError()
	}
	return s, nil
}

// inboundGroupSessionSize is the size of an inbound group session object in
// bytes.
func inboundGroupSessionSize() uint {
	return uint(( /*line :90:14*/_Cfunc_olm_inbound_group_session_size /*line :90:45*/)())
}

// newInboundGroupSession initialises an empty InboundGroupSession.
func NewBlankInboundGroupSession() *InboundGroupSession {
	memory := make([]byte, inboundGroupSessionSize())
	return &InboundGroupSession{
		int: func() *_Ctype_struct_OlmInboundGroupSession{ _cgo0 := /*line :97:36*/unsafe.Pointer(unsafe.SliceData(memory)); _cgoCheckPointer(_cgo0, nil); return /*line :97:77*/_Cfunc_olm_inbound_group_session(_cgo0); }(),
		mem: memory,
	}
}

// lastError returns an error describing the most recent error to happen to an
// inbound group session.
func (s *InboundGroupSession) lastError() error {
	return convertError(( /*line :105:22*/_Cfunc_GoString /*line :105:31*/)(func() *_Ctype_char{ _cgo0 := /*line :105:72*/(*_Ctype_OlmInboundGroupSession /*line :105:98*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :105:107*/_Cfunc_olm_inbound_group_session_last_error(_cgo0); }()))
}

// Clear clears the memory used to back this InboundGroupSession.
func (s *InboundGroupSession) Clear() error {
	r := func() _Ctype_size_t{ _cgo0 := /*line :110:41*/(*_Ctype_OlmInboundGroupSession /*line :110:67*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :110:76*/_Cfunc_olm_clear_inbound_group_session(_cgo0); }()
	if r == errorVal() {
		return s.lastError()
	}
	return nil
}

// pickleLen returns the number of bytes needed to store an inbound group
// session.
func (s *InboundGroupSession) pickleLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :120:56*/(*_Ctype_OlmInboundGroupSession /*line :120:82*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :120:91*/_Cfunc_olm_pickle_inbound_group_session_length(_cgo0); }())
}

// Pickle returns an InboundGroupSession as a base64 string.  Encrypts the
// InboundGroupSession using the supplied key.
func (s *InboundGroupSession) Pickle(key []byte) ([]byte, error) {
	if len(key) == 0 {
		return nil, olm.NoKeyProvided
	}
	pickled := make([]byte, s.pickleLen())
	r := func() _Ctype_size_t{ _cgo0 := /*line :131:3*/(*_Ctype_OlmInboundGroupSession /*line :131:29*/)(s.int); _cgo1 := /*line :132:3*/unsafe.Pointer(unsafe.SliceData(key)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :133:11*/(len(key)); _cgo3 := /*line :134:3*/unsafe.Pointer(unsafe.SliceData(pickled)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :135:11*/(len(pickled)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); return /*line :136:3*/_Cfunc_olm_pickle_inbound_group_session(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	runtime.KeepAlive(key)
	if r == errorVal() {
		return nil, s.lastError()
	}
	return pickled[:r], nil
}

func (s *InboundGroupSession) Unpickle(pickled, key []byte) error {
	if len(key) == 0 {
		return olm.NoKeyProvided
	} else if len(pickled) == 0 {
		return olm.EmptyInput
	}
	r := func() _Ctype_size_t{ _cgo0 := /*line :151:3*/(*_Ctype_OlmInboundGroupSession /*line :151:29*/)(s.int); _cgo1 := /*line :152:3*/unsafe.Pointer(unsafe.SliceData(key)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :153:11*/(len(key)); _cgo3 := /*line :154:3*/unsafe.Pointer(unsafe.SliceData(pickled)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :155:11*/(len(pickled)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); return /*line :156:3*/_Cfunc_olm_unpickle_inbound_group_session(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	runtime.KeepAlive(key)
	if r == errorVal() {
		return s.lastError()
	}
	return nil
}

// Deprecated
func (s *InboundGroupSession) GobEncode() ([]byte, error) {
	pickled, err := s.Pickle(pickleKey)
	if err != nil {
		return nil, err
	}
	length := base64.RawStdEncoding.DecodedLen(len(pickled))
	rawPickled := make([]byte, length)
	_, err = base64.RawStdEncoding.Decode(rawPickled, pickled)
	return rawPickled, err
}

// Deprecated
func (s *InboundGroupSession) GobDecode(rawPickled []byte) error {
	if s == nil || s.int == nil {
		*s = *NewBlankInboundGroupSession()
	}
	length := base64.RawStdEncoding.EncodedLen(len(rawPickled))
	pickled := make([]byte, length)
	base64.RawStdEncoding.Encode(pickled, rawPickled)
	return s.Unpickle(pickled, pickleKey)
}

// Deprecated
func (s *InboundGroupSession) MarshalJSON() ([]byte, error) {
	pickled, err := s.Pickle(pickleKey)
	if err != nil {
		return nil, err
	}
	quotes := make([]byte, len(pickled)+2)
	quotes[0] = '"'
	quotes[len(quotes)-1] = '"'
	copy(quotes[1:len(quotes)-1], pickled)
	return quotes, nil
}

// Deprecated
func (s *InboundGroupSession) UnmarshalJSON(data []byte) error {
	if len(data) == 0 || data[0] != '"' || data[len(data)-1] != '"' {
		return olm.InputNotJSONString
	}
	if s == nil || s.int == nil {
		*s = *NewBlankInboundGroupSession()
	}
	return s.Unpickle(data[1:len(data)-1], pickleKey)
}

// decryptMaxPlaintextLen returns the maximum number of bytes of plain-text a
// given message could decode to.  The actual size could be different due to
// padding.  Returns error on failure.  If the message base64 couldn't be
// decoded then the error will be "INVALID_BASE64".  If the message is for an
// unsupported version of the protocol then the error will be
// "BAD_MESSAGE_VERSION".  If the message couldn't be decoded then the error
// will be "BAD_MESSAGE_FORMAT".
func (s *InboundGroupSession) decryptMaxPlaintextLen(message []byte) (uint, error) {
	if len(message) == 0 {
		return 0, olm.EmptyInput
	}
	// olm_group_decrypt_max_plaintext_length destroys the input, so we have to clone it
	messageCopy := bytes.Clone(message)
	r := func() _Ctype_size_t{ _cgo0 := /*line :225:3*/(*_Ctype_OlmInboundGroupSession /*line :225:29*/)(s.int); var _cgo1 *_Ctype_uint8_t = /*line :226:3*/(*_Ctype_uint8_t /*line :226:14*/)(unsafe.Pointer(unsafe.SliceData(messageCopy))); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :227:11*/(len(messageCopy)); _cgoCheckPointer(_cgo0, nil); return /*line :228:3*/_Cfunc_olm_group_decrypt_max_plaintext_length(_cgo0, _cgo1, _cgo2); }()
	runtime.KeepAlive(messageCopy)
	if r == errorVal() {
		return 0, s.lastError()
	}
	return uint(r), nil
}

// Decrypt decrypts a message using the InboundGroupSession.  Returns the the
// plain-text and message index on success.  Returns error on failure.  If the
// base64 couldn't be decoded then the error will be "INVALID_BASE64".  If the
// message is for an unsupported version of the protocol then the error will be
// "BAD_MESSAGE_VERSION".  If the message couldn't be decoded then the error
// will be BAD_MESSAGE_FORMAT".  If the MAC on the message was invalid then the
// error will be "BAD_MESSAGE_MAC".  If we do not have a session key
// corresponding to the message's index (ie, it was sent before the session key
// was shared with us) the error will be "OLM_UNKNOWN_MESSAGE_INDEX".
func (s *InboundGroupSession) Decrypt(message []byte) ([]byte, uint, error) {
	if len(message) == 0 {
		return nil, 0, olm.EmptyInput
	}
	decryptMaxPlaintextLen, err := s.decryptMaxPlaintextLen(message)
	if err != nil {
		return nil, 0, err
	}
	messageCopy := bytes.Clone(message)
	plaintext := make([]byte, decryptMaxPlaintextLen)
	var messageIndex uint32
	r := func() _Ctype_size_t{ _cgo0 := /*line :257:3*/(*_Ctype_OlmInboundGroupSession /*line :257:29*/)(s.int); var _cgo1 *_Ctype_uint8_t = /*line :258:3*/(*_Ctype_uint8_t /*line :258:14*/)(unsafe.Pointer(unsafe.SliceData(messageCopy))); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :259:11*/(len(messageCopy)); var _cgo3 *_Ctype_uint8_t = /*line :260:3*/(*_Ctype_uint8_t /*line :260:14*/)(unsafe.Pointer(unsafe.SliceData(plaintext))); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :261:11*/(len(plaintext)); var _cgo5 *_Ctype_uint32_t = /*line :262:3*/(*_Ctype_uint32_t /*line :262:15*/)(unsafe.Pointer(&messageIndex)); _cgoCheckPointer(_cgo0, nil); return /*line :263:3*/_Cfunc_olm_group_decrypt(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	runtime.KeepAlive(messageCopy)
	if r == errorVal() {
		return nil, 0, s.lastError()
	}
	return plaintext[:r], uint(messageIndex), nil
}

// sessionIdLen returns the number of bytes needed to store a session ID.
func (s *InboundGroupSession) sessionIdLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :273:52*/(*_Ctype_OlmInboundGroupSession /*line :273:78*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :273:87*/_Cfunc_olm_inbound_group_session_id_length(_cgo0); }())
}

// ID returns a base64-encoded identifier for this session.
func (s *InboundGroupSession) ID() id.SessionID {
	sessionID := make([]byte, s.sessionIdLen())
	r := func() _Ctype_size_t{ _cgo0 := /*line :280:3*/(*_Ctype_OlmInboundGroupSession /*line :280:29*/)(s.int); var _cgo1 *_Ctype_uint8_t = /*line :281:3*/(*_Ctype_uint8_t /*line :281:14*/)(unsafe.Pointer(unsafe.SliceData(sessionID))); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :282:11*/(len(sessionID)); _cgoCheckPointer(_cgo0, nil); return /*line :283:3*/_Cfunc_olm_inbound_group_session_id(_cgo0, _cgo1, _cgo2); }()
	if r == errorVal() {
		panic(s.lastError())
	}
	return id.SessionID(sessionID[:r])
}

// FirstKnownIndex returns the first message index we know how to decrypt.
func (s *InboundGroupSession) FirstKnownIndex() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :292:62*/(*_Ctype_OlmInboundGroupSession /*line :292:88*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :292:97*/_Cfunc_olm_inbound_group_session_first_known_index(_cgo0); }())
}

// IsVerified check if the session has been verified as a valid session.  (A
// session is verified either because the original session share was signed, or
// because we have subsequently successfully decrypted a message.)
func (s *InboundGroupSession) IsVerified() bool {
	return uint(func() _Ctype_int{ _cgo0 := /*line :299:54*/(*_Ctype_OlmInboundGroupSession /*line :299:80*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :299:89*/_Cfunc_olm_inbound_group_session_is_verified(_cgo0); }()) == 1
}

// exportLen returns the number of bytes needed to export an inbound group
// session.
func (s *InboundGroupSession) exportLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :305:56*/(*_Ctype_OlmInboundGroupSession /*line :305:82*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :305:91*/_Cfunc_olm_export_inbound_group_session_length(_cgo0); }())
}

// Export returns the base64-encoded ratchet key for this session, at the given
// index, in a format which can be used by
// InboundGroupSession.InboundGroupSessionImport().  Encrypts the
// InboundGroupSession using the supplied key.  Returns error on failure.
// if we do not have a session key corresponding to the given index (ie, it was
// sent before the session key was shared with us) the error will be
// "OLM_UNKNOWN_MESSAGE_INDEX".
func (s *InboundGroupSession) Export(messageIndex uint32) ([]byte, error) {
	key := make([]byte, s.exportLen())
	r := func() _Ctype_size_t{ _cgo0 := /*line :318:3*/(*_Ctype_OlmInboundGroupSession /*line :318:29*/)(s.int); var _cgo1 *_Ctype_uint8_t = /*line :319:3*/(*_Ctype_uint8_t /*line :319:14*/)(unsafe.Pointer(unsafe.SliceData(key))); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :320:11*/(len(key)); var _cgo3 _Ctype_uint32_t = _Ctype_uint32_t /*line :321:13*/(messageIndex); _cgoCheckPointer(_cgo0, nil); return /*line :322:3*/_Cfunc_olm_export_inbound_group_session(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if r == errorVal() {
		return nil, s.lastError()
	}
	return key[:r], nil
}
