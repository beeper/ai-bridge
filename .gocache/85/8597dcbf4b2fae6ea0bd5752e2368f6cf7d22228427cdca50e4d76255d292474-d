// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/joshpa8c/Documents/Dev/beepAI/third_party/mautrix/crypto/libolm/outboundgroupsession.go:1:1
package libolm

// #cgo LDFLAGS: -lolm -lstdc++
// #include <olm/olm.h>
import _ "unsafe"

import (
	"crypto/rand"
	"encoding/base64"
	"runtime"
	"unsafe"

	"maunium.net/go/mautrix/crypto/olm"
	"maunium.net/go/mautrix/id"
)

// OutboundGroupSession stores an outbound encrypted messaging session
// for a group.
type OutboundGroupSession struct {
	int * /*line :20:7*/_Ctype_OlmOutboundGroupSession /*line :20:32*/
	mem []byte
}

// Ensure that [OutboundGroupSession] implements [olm.OutboundGroupSession].
var _ olm.OutboundGroupSession = (*OutboundGroupSession)(nil)

func NewOutboundGroupSession() (*OutboundGroupSession, error) {
	s := NewBlankOutboundGroupSession()
	random := make([]byte, s.createRandomLen()+1)
	_, err := rand.Read(random)
	if err != nil {
		return nil, err
	}
	r := func() _Ctype_size_t{ _cgo0 := /*line :35:3*/(*_Ctype_OlmOutboundGroupSession /*line :35:30*/)(s.int); var _cgo1 *_Ctype_uint8_t = /*line :36:3*/(*_Ctype_uint8_t /*line :36:14*/)(unsafe.Pointer(unsafe.SliceData(random))); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :37:11*/(len(random)); _cgoCheckPointer(_cgo0, nil); return /*line :38:3*/_Cfunc_olm_init_outbound_group_session(_cgo0, _cgo1, _cgo2); }()
	runtime.KeepAlive(random)
	if r == errorVal() {
		return nil, s.lastError()
	}
	return s, nil
}

// outboundGroupSessionSize is the size of an outbound group session object in
// bytes.
func outboundGroupSessionSize() uint {
	return uint(( /*line :49:14*/_Cfunc_olm_outbound_group_session_size /*line :49:46*/)())
}

// NewBlankOutboundGroupSession initialises an empty [OutboundGroupSession].
func NewBlankOutboundGroupSession() *OutboundGroupSession {
	memory := make([]byte, outboundGroupSessionSize())
	return &OutboundGroupSession{
		int: func() *_Ctype_struct_OlmOutboundGroupSession{ _cgo0 := /*line :56:37*/unsafe.Pointer(unsafe.SliceData(memory)); _cgoCheckPointer(_cgo0, nil); return /*line :56:78*/_Cfunc_olm_outbound_group_session(_cgo0); }(),
		mem: memory,
	}
}

// lastError returns an error describing the most recent error to happen to an
// outbound group session.
func (s *OutboundGroupSession) lastError() error {
	return convertError(( /*line :64:22*/_Cfunc_GoString /*line :64:31*/)(func() *_Ctype_char{ _cgo0 := /*line :64:73*/(*_Ctype_OlmOutboundGroupSession /*line :64:100*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :64:109*/_Cfunc_olm_outbound_group_session_last_error(_cgo0); }()))
}

// Clear clears the memory used to back this OutboundGroupSession.
func (s *OutboundGroupSession) Clear() error {
	r := func() _Ctype_size_t{ _cgo0 := /*line :69:42*/(*_Ctype_OlmOutboundGroupSession /*line :69:69*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :69:78*/_Cfunc_olm_clear_outbound_group_session(_cgo0); }()
	if r == errorVal() {
		return s.lastError()
	} else {
		return nil
	}
}

// pickleLen returns the number of bytes needed to store an outbound group
// session.
func (s *OutboundGroupSession) pickleLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :80:57*/(*_Ctype_OlmOutboundGroupSession /*line :80:84*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :80:93*/_Cfunc_olm_pickle_outbound_group_session_length(_cgo0); }())
}

// Pickle returns an OutboundGroupSession as a base64 string.  Encrypts the
// OutboundGroupSession using the supplied key.
func (s *OutboundGroupSession) Pickle(key []byte) ([]byte, error) {
	if len(key) == 0 {
		return nil, olm.NoKeyProvided
	}
	pickled := make([]byte, s.pickleLen())
	r := func() _Ctype_size_t{ _cgo0 := /*line :91:3*/(*_Ctype_OlmOutboundGroupSession /*line :91:30*/)(s.int); _cgo1 := /*line :92:3*/unsafe.Pointer(unsafe.SliceData(key)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :93:11*/(len(key)); _cgo3 := /*line :94:3*/unsafe.Pointer(unsafe.SliceData(pickled)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :95:11*/(len(pickled)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); return /*line :96:3*/_Cfunc_olm_pickle_outbound_group_session(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	runtime.KeepAlive(key)
	if r == errorVal() {
		return nil, s.lastError()
	}
	return pickled[:r], nil
}

func (s *OutboundGroupSession) Unpickle(pickled, key []byte) error {
	if len(key) == 0 {
		return olm.NoKeyProvided
	}
	r := func() _Ctype_size_t{ _cgo0 := /*line :109:3*/(*_Ctype_OlmOutboundGroupSession /*line :109:30*/)(s.int); _cgo1 := /*line :110:3*/unsafe.Pointer(unsafe.SliceData(key)); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :111:11*/(len(key)); _cgo3 := /*line :112:3*/unsafe.Pointer(unsafe.SliceData(pickled)); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :113:11*/(len(pickled)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo3, nil); return /*line :114:3*/_Cfunc_olm_unpickle_outbound_group_session(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	runtime.KeepAlive(pickled)
	runtime.KeepAlive(key)
	if r == errorVal() {
		return s.lastError()
	}
	return nil
}

// Deprecated
func (s *OutboundGroupSession) GobEncode() ([]byte, error) {
	pickled, err := s.Pickle(pickleKey)
	if err != nil {
		return nil, err
	}
	length := base64.RawStdEncoding.DecodedLen(len(pickled))
	rawPickled := make([]byte, length)
	_, err = base64.RawStdEncoding.Decode(rawPickled, pickled)
	return rawPickled, err
}

// Deprecated
func (s *OutboundGroupSession) GobDecode(rawPickled []byte) error {
	if s == nil || s.int == nil {
		*s = *NewBlankOutboundGroupSession()
	}
	length := base64.RawStdEncoding.EncodedLen(len(rawPickled))
	pickled := make([]byte, length)
	base64.RawStdEncoding.Encode(pickled, rawPickled)
	return s.Unpickle(pickled, pickleKey)
}

// Deprecated
func (s *OutboundGroupSession) MarshalJSON() ([]byte, error) {
	pickled, err := s.Pickle(pickleKey)
	if err != nil {
		return nil, err
	}
	quotes := make([]byte, len(pickled)+2)
	quotes[0] = '"'
	quotes[len(quotes)-1] = '"'
	copy(quotes[1:len(quotes)-1], pickled)
	return quotes, nil
}

// Deprecated
func (s *OutboundGroupSession) UnmarshalJSON(data []byte) error {
	if len(data) == 0 || data[0] != '"' || data[len(data)-1] != '"' {
		return olm.InputNotJSONString
	}
	if s == nil || s.int == nil {
		*s = *NewBlankOutboundGroupSession()
	}
	return s.Unpickle(data[1:len(data)-1], pickleKey)
}

// createRandomLen returns the number of random bytes needed to create an
// Account.
func (s *OutboundGroupSession) createRandomLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :173:62*/(*_Ctype_OlmOutboundGroupSession /*line :173:89*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :173:98*/_Cfunc_olm_init_outbound_group_session_random_length(_cgo0); }())
}

// encryptMsgLen returns the size of the next message in bytes for the given
// number of plain-text bytes.
func (s *OutboundGroupSession) encryptMsgLen(plainTextLen int) uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :179:49*/(*_Ctype_OlmOutboundGroupSession /*line :179:76*/)(s.int); var _cgo1 _Ctype_size_t = _Ctype_size_t /*line :179:94*/(plainTextLen); _cgoCheckPointer(_cgo0, nil); return /*line :179:109*/_Cfunc_olm_group_encrypt_message_length(_cgo0, _cgo1); }())
}

// Encrypt encrypts a message using the Session.  Returns the encrypted message
// as base64.
func (s *OutboundGroupSession) Encrypt(plaintext []byte) ([]byte, error) {
	if len(plaintext) == 0 {
		return nil, olm.EmptyInput
	}
	message := make([]byte, s.encryptMsgLen(len(plaintext)))
	r := func() _Ctype_size_t{ _cgo0 := /*line :190:3*/(*_Ctype_OlmOutboundGroupSession /*line :190:30*/)(s.int); var _cgo1 *_Ctype_uint8_t = /*line :191:3*/(*_Ctype_uint8_t /*line :191:14*/)(unsafe.Pointer(unsafe.SliceData(plaintext))); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :192:11*/(len(plaintext)); var _cgo3 *_Ctype_uint8_t = /*line :193:3*/(*_Ctype_uint8_t /*line :193:14*/)(unsafe.Pointer(unsafe.SliceData(message))); var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :194:11*/(len(message)); _cgoCheckPointer(_cgo0, nil); return /*line :195:3*/_Cfunc_olm_group_encrypt(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	runtime.KeepAlive(plaintext)
	if r == errorVal() {
		return nil, s.lastError()
	}
	return message[:r], nil
}

// sessionIdLen returns the number of bytes needed to store a session ID.
func (s *OutboundGroupSession) sessionIdLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :205:53*/(*_Ctype_OlmOutboundGroupSession /*line :205:80*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :205:89*/_Cfunc_olm_outbound_group_session_id_length(_cgo0); }())
}

// ID returns a base64-encoded identifier for this session.
func (s *OutboundGroupSession) ID() id.SessionID {
	sessionID := make([]byte, s.sessionIdLen())
	r := func() _Ctype_size_t{ _cgo0 := /*line :212:3*/(*_Ctype_OlmOutboundGroupSession /*line :212:30*/)(s.int); var _cgo1 *_Ctype_uint8_t = /*line :213:3*/(*_Ctype_uint8_t /*line :213:14*/)(unsafe.Pointer(unsafe.SliceData(sessionID))); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :214:11*/(len(sessionID)); _cgoCheckPointer(_cgo0, nil); return /*line :215:3*/_Cfunc_olm_outbound_group_session_id(_cgo0, _cgo1, _cgo2); }()
	if r == errorVal() {
		panic(s.lastError())
	}
	return id.SessionID(sessionID[:r])
}

// MessageIndex returns the message index for this session.  Each message is
// sent with an increasing index; this returns the index for the next message.
func (s *OutboundGroupSession) MessageIndex() uint {
	return uint(func() _Ctype_uint32_t{ _cgo0 := /*line :225:57*/(*_Ctype_OlmOutboundGroupSession /*line :225:84*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :225:93*/_Cfunc_olm_outbound_group_session_message_index(_cgo0); }())
}

// sessionKeyLen returns the number of bytes needed to store a session key.
func (s *OutboundGroupSession) sessionKeyLen() uint {
	return uint(func() _Ctype_size_t{ _cgo0 := /*line :230:54*/(*_Ctype_OlmOutboundGroupSession /*line :230:81*/)(s.int); _cgoCheckPointer(_cgo0, nil); return /*line :230:90*/_Cfunc_olm_outbound_group_session_key_length(_cgo0); }())
}

// Key returns the base64-encoded current ratchet key for this session.
func (s *OutboundGroupSession) Key() string {
	sessionKey := make([]byte, s.sessionKeyLen())
	r := func() _Ctype_size_t{ _cgo0 := /*line :237:3*/(*_Ctype_OlmOutboundGroupSession /*line :237:30*/)(s.int); var _cgo1 *_Ctype_uint8_t = /*line :238:3*/(*_Ctype_uint8_t /*line :238:14*/)(unsafe.Pointer(unsafe.SliceData(sessionKey))); var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :239:11*/(len(sessionKey)); _cgoCheckPointer(_cgo0, nil); return /*line :240:3*/_Cfunc_olm_outbound_group_session_key(_cgo0, _cgo1, _cgo2); }()
	if r == errorVal() {
		panic(s.lastError())
	}
	return string(sessionKey[:r])
}
