diff a/pkg/connector/handleai.go b/pkg/connector/handleai.go	(rejected hunks)
@@ -9,6 +9,7 @@ import (
 	"strings"
 	"time"
 
+	"github.com/beeper/ai-bridge/pkg/agents/tools"
 	"github.com/google/uuid"
 	"github.com/openai/openai-go/v3"
 	"github.com/openai/openai-go/v3/responses"
@@ -202,7 +203,7 @@ func (oc *AIClient) streamingResponseWithRetry(
 }
 
 // buildResponsesAPIParams creates common Responses API parameters for both streaming and non-streaming paths
-func (oc *AIClient) buildResponsesAPIParams(ctx context.Context, meta *PortalMetadata, messages []openai.ChatCompletionMessageParamUnion) responses.ResponseNewParams {
+func (oc *AIClient) buildResponsesAPIParams(ctx context.Context, portal *bridgev2.Portal, meta *PortalMetadata, messages []openai.ChatCompletionMessageParamUnion) responses.ResponseNewParams {
 	log := zerolog.Ctx(ctx)
 
 	params := responses.ResponseNewParams{
@@ -258,9 +259,34 @@ func (oc *AIClient) buildResponsesAPIParams(ctx context.Context, meta *PortalMet
 		}
 	}
 
+	// Add boss tools if this is the Builder room
+	if oc.isBuilderRoom(portal) {
+		bossTools := tools.BossTools()
+		params.Tools = append(params.Tools, bossToolsToOpenAI(bossTools)...)
+		log.Debug().Int("count", len(bossTools)).Msg("Added boss agent tools")
+	}
+
 	return params
 }
 
+// bossToolsToOpenAI converts boss tools to OpenAI Responses API format.
+func bossToolsToOpenAI(bossTools []*tools.Tool) []responses.ToolUnionParam {
+	var result []responses.ToolUnionParam
+	for _, t := range bossTools {
+		funcParam := responses.FunctionToolParam{
+			Name:        t.Name,
+			Description: openai.String(t.Description),
+		}
+		if schema, ok := t.InputSchema.(map[string]any); ok {
+			funcParam.Parameters = schema
+		}
+		result = append(result, responses.ToolUnionParam{
+			OfFunction: &funcParam,
+		})
+	}
+	return result
+}
+
 // streamingResponse handles streaming using the Responses API
 // This is the preferred streaming method as it supports reasoning tokens
 // Returns (success, contextLengthError)
@@ -280,7 +306,7 @@ func (oc *AIClient) streamingResponse(
 	defer oc.setModelTyping(ctx, portal, false)
 
 	// Build Responses API params using shared helper
-	params := oc.buildResponsesAPIParams(ctx, meta, messages)
+	params := oc.buildResponsesAPIParams(ctx, portal, meta, messages)
 
 	// Inject per-room PDF engine into context for OpenRouter/Beeper providers
 	if oc.isOpenRouterProvider() {
@@ -406,7 +432,7 @@ func (oc *AIClient) streamingResponse(
 			}
 
 			if state.initialEventID != "" && oc.isToolEnabled(meta, streamEvent.Name) {
-				result, err := oc.executeBuiltinTool(ctx, streamEvent.Name, streamEvent.Arguments)
+				result, err := oc.executeBuiltinTool(ctx, portal, streamEvent.Name, streamEvent.Arguments)
 				resultStatus := ResultStatusSuccess
 				if err != nil {
 					log.Warn().Err(err).Str("tool", streamEvent.Name).Msg("Tool execution failed")
@@ -795,7 +821,7 @@ func (oc *AIClient) streamChatCompletions(
 	// Execute any accumulated tool calls
 	for _, tool := range activeTools {
 		if tool.input.Len() > 0 && tool.toolName != "" && oc.isToolEnabled(meta, tool.toolName) {
-			result, err := oc.executeBuiltinTool(ctx, tool.toolName, tool.input.String())
+			result, err := oc.executeBuiltinTool(ctx, portal, tool.toolName, tool.input.String())
 			resultStatus := ResultStatusSuccess
 			if err != nil {
 				log.Warn().Err(err).Str("tool", tool.toolName).Msg("Tool execution failed (Chat Completions)")
@@ -1352,13 +1378,22 @@ func (oc *AIClient) sendToolResultEvent(ctx context.Context, portal *bridgev2.Po
 	return resp.EventID
 }
 
-// executeBuiltinTool finds and executes a builtin tool by name
-func (oc *AIClient) executeBuiltinTool(ctx context.Context, toolName string, argsJSON string) (string, error) {
+// executeBuiltinTool finds and executes a builtin tool by name.
+// For Builder room, this also handles boss agent tools.
+func (oc *AIClient) executeBuiltinTool(ctx context.Context, portal *bridgev2.Portal, toolName string, argsJSON string) (string, error) {
 	var args map[string]any
 	if err := json.Unmarshal([]byte(argsJSON), &args); err != nil {
 		return "", fmt.Errorf("invalid tool arguments: %w", err)
 	}
 
+	// Check if this is the Builder room - use boss tool executor for boss tools
+	if oc.isBuilderRoom(portal) {
+		if result := oc.executeBossTool(ctx, toolName, args); result != nil {
+			return result.Content, result.Error
+		}
+	}
+
+	// Standard builtin tools
 	for _, tool := range BuiltinTools() {
 		if tool.Name == toolName {
 			return tool.Execute(ctx, args)
@@ -1367,6 +1402,56 @@ func (oc *AIClient) executeBuiltinTool(ctx context.Context, toolName string, arg
 	return "", fmt.Errorf("unknown tool: %s", toolName)
 }
 
+// bossToolResult holds the result from a boss tool execution.
+type bossToolResult struct {
+	Content string
+	Error   error
+}
+
+// executeBossTool attempts to execute a boss agent tool.
+// Returns nil if the tool is not a boss tool.
+func (oc *AIClient) executeBossTool(ctx context.Context, toolName string, args map[string]any) *bossToolResult {
+	// Create boss tool executor with store adapter
+	store := NewBossStoreAdapter(oc)
+	executor := tools.NewBossToolExecutor(store)
+
+	var result *tools.Result
+	var err error
+
+	switch toolName {
+	case "create_agent":
+		result, err = executor.ExecuteCreateAgent(ctx, args)
+	case "fork_agent":
+		result, err = executor.ExecuteForkAgent(ctx, args)
+	case "edit_agent":
+		result, err = executor.ExecuteEditAgent(ctx, args)
+	case "delete_agent":
+		result, err = executor.ExecuteDeleteAgent(ctx, args)
+	case "list_agents":
+		result, err = executor.ExecuteListAgents(ctx, args)
+	case "list_models":
+		result, err = executor.ExecuteListModels(ctx, args)
+	case "list_tools":
+		result, err = executor.ExecuteListTools(ctx, args)
+	default:
+		return nil // Not a boss tool
+	}
+
+	if err != nil {
+		return &bossToolResult{Error: err}
+	}
+	if result == nil {
+		return &bossToolResult{Content: ""}
+	}
+
+	// Extract content from result
+	content := result.Text()
+	if result.Status == tools.ResultError {
+		return &bossToolResult{Error: fmt.Errorf("%s", content)}
+	}
+	return &bossToolResult{Content: content}
+}
+
 // notifyMatrixSendFailure sends an error status back to Matrix
 func (oc *AIClient) notifyMatrixSendFailure(ctx context.Context, portal *bridgev2.Portal, evt *event.Event, err error) {
 	// Check for auth errors (401/403) - trigger reauth with StateBadCredentials
