package connector

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"sync"
	"time"

	"maunium.net/go/mautrix/bridgev2"
	"maunium.net/go/mautrix/bridgev2/commands"
	"maunium.net/go/mautrix/bridgev2/networkid"
	"maunium.net/go/mautrix/event"
	"maunium.net/go/mautrix/format"
	"maunium.net/go/mautrix/id"

	"github.com/beeper/ai-bridge/pkg/agents"
	"github.com/beeper/ai-bridge/pkg/agents/tools"
	"github.com/google/uuid"
)

// AgentStoreAdapter implements agents.AgentStore using Matrix state events.
type AgentStoreAdapter struct {
	client *AIClient
	mu     sync.Mutex // protects read-modify-write operations on custom agents
}

// NewAgentStoreAdapter creates a new agent store adapter.
func NewAgentStoreAdapter(client *AIClient) *AgentStoreAdapter {
	return &AgentStoreAdapter{client: client}
}

// LoadAgents implements agents.AgentStore.
// It loads agents from preset definitions and per-agent hidden data rooms.
func (s *AgentStoreAdapter) LoadAgents(ctx context.Context) (map[string]*agents.AgentDefinition, error) {
	// Start with preset agents
	result := make(map[string]*agents.AgentDefinition)

	// Add all presets
	for _, preset := range agents.PresetAgents {
		result[preset.ID] = preset.Clone()
	}

	// Add boss agent
	result[agents.BossAgent.ID] = agents.BossAgent.Clone()

	// Load custom agents from their individual hidden data rooms
	customAgents, err := s.loadAllCustomAgents(ctx)
	if err != nil {
		s.client.log.Warn().Err(err).Msg("Failed to load custom agents from data rooms")
		// Continue with just presets if load fails
	}
	for id, content := range customAgents {
		result[id] = FromAgentDefinitionContent(content)
	}

	return result, nil
}

// loadAllCustomAgents scans for agent data rooms and loads their contents.
// Each custom agent has its own hidden room with a deterministic ID.
func (s *AgentStoreAdapter) loadAllCustomAgents(ctx context.Context) (map[string]*AgentDefinitionContent, error) {
	result := make(map[string]*AgentDefinitionContent)

	// Get all portals owned by this user login
	allDBPortals, err := s.client.UserLogin.Bridge.DB.Portal.GetAll(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list portals: %w", err)
	}

	for _, dbPortal := range allDBPortals {
		// Filter to only portals owned by this user login
		if dbPortal.Receiver != s.client.UserLogin.ID {
			continue
		}

		// Check if this is an agent data room
		agentID, ok := parseAgentIDFromDataRoom(dbPortal.ID)
		if !ok {
			continue
		}

		// Load agent data from this room
		content, err := s.loadAgentFromDataRoom(ctx, agentID)
		if err != nil {
			s.client.log.Warn().Err(err).Str("agent_id", agentID).Msg("Failed to load agent from data room")
			continue
		}
		if content != nil {
			result[agentID] = content
		}
	}

	return result, nil
}

// getOrCreateAgentDataRoom returns or creates the hidden data room for an agent.
func (s *AgentStoreAdapter) getOrCreateAgentDataRoom(ctx context.Context, agentID string) (*bridgev2.Portal, error) {
	portalKey := agentDataPortalKey(s.client.UserLogin.ID, agentID)

	portal, err := s.client.UserLogin.Bridge.GetPortalByKey(ctx, portalKey)
	if err != nil {
		return nil, fmt.Errorf("failed to get portal: %w", err)
	}

	// Check if portal already exists with a Matrix room
	if portal.MXID != "" {
		return portal, nil
	}

	// Create the portal and Matrix room
	return s.createAgentDataRoom(ctx, agentID)
}

// createAgentDataRoom creates a hidden room for storing agent data.
func (s *AgentStoreAdapter) createAgentDataRoom(ctx context.Context, agentID string) (*bridgev2.Portal, error) {
	portalKey := agentDataPortalKey(s.client.UserLogin.ID, agentID)

	portal, err := s.client.UserLogin.Bridge.GetPortalByKey(ctx, portalKey)
	if err != nil {
		return nil, fmt.Errorf("failed to get portal: %w", err)
	}

	// Set up portal metadata for hidden agent data room
	portal.Metadata = &PortalMetadata{
		IsAgentDataRoom: true,
		AgentID:         agentID,
	}
	portal.Name = fmt.Sprintf("Agent Data: %s", agentID)
	portal.NameSet = true

	if err := portal.Save(ctx); err != nil {
		return nil, fmt.Errorf("failed to save portal: %w", err)
	}

	// Create the Matrix room (hidden from clients via BeeperRoomTypeV2)
	chatInfo := &bridgev2.ChatInfo{
		Name: &portal.Name,
	}
	if err := portal.CreateMatrixRoom(ctx, s.client.UserLogin, chatInfo); err != nil {
		return nil, fmt.Errorf("failed to create Matrix room: %w", err)
	}

	s.client.log.Info().Str("agent_id", agentID).Stringer("portal", portal.PortalKey).Msg("Created agent data room")
	return portal, nil
}

// loadAgentFromDataRoom loads agent definition from its hidden room.
func (s *AgentStoreAdapter) loadAgentFromDataRoom(ctx context.Context, agentID string) (*AgentDefinitionContent, error) {
	portalKey := agentDataPortalKey(s.client.UserLogin.ID, agentID)

	portal, err := s.client.UserLogin.Bridge.GetPortalByKey(ctx, portalKey)
	if err != nil {
		return nil, fmt.Errorf("failed to get portal: %w", err)
	}
	if portal.MXID == "" {
		return nil, nil // Room doesn't exist yet
	}

	// Get the Matrix connector to read state events
	matrixConn := s.client.UserLogin.Bridge.Matrix
	stateConn, ok := matrixConn.(bridgev2.MatrixConnectorWithArbitraryRoomState)
	if !ok {
		return nil, fmt.Errorf("matrix connector does not support state access")
	}

	// Read the agent data state event
	evt, err := stateConn.GetStateEvent(ctx, portal.MXID, AgentDataEventType, "")
	if err != nil {
		// State event doesn't exist yet - this is normal for newly created rooms
		return nil, nil
	}

	// Parse the content
	var content AgentDataEventContent
	if err := json.Unmarshal(evt.Content.VeryRaw, &content); err != nil {
		return nil, fmt.Errorf("failed to parse agent data event: %w", err)
	}

	return content.Agent, nil
}

// saveAgentToDataRoom saves agent definition to its hidden room.
func (s *AgentStoreAdapter) saveAgentToDataRoom(ctx context.Context, agent *AgentDefinitionContent) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	// Get or create the agent's data room
	portal, err := s.getOrCreateAgentDataRoom(ctx, agent.ID)
	if err != nil {
		return fmt.Errorf("failed to get/create agent data room: %w", err)
	}

	// Send the agent data state event
	content := &AgentDataEventContent{
		Agent: agent,
	}

	bot := s.client.UserLogin.Bridge.Bot
	_, err = bot.SendState(ctx, portal.MXID, AgentDataEventType, "", &event.Content{
		Parsed: content,
	}, time.Time{})
	if err != nil {
		return fmt.Errorf("failed to send agent data state event: %w", err)
	}

	return nil
}

// deleteAgentDataRoom deletes the hidden data room for an agent.
func (s *AgentStoreAdapter) deleteAgentDataRoom(ctx context.Context, agentID string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	portalKey := agentDataPortalKey(s.client.UserLogin.ID, agentID)

	portal, err := s.client.UserLogin.Bridge.GetPortalByKey(ctx, portalKey)
	if err != nil {
		return fmt.Errorf("failed to get portal: %w", err)
	}
	if portal == nil {
		return nil // Already doesn't exist
	}

	// Delete the Matrix room if it exists
	if portal.MXID != "" {
		if err := portal.Delete(ctx); err != nil {
			s.client.log.Warn().Err(err).Str("agent_id", agentID).Msg("Failed to delete agent data room")
			// Continue to delete the portal from database even if Matrix delete fails
		}
	}

	// Delete the portal from database
	if err := s.client.UserLogin.Bridge.DB.Portal.Delete(ctx, portalKey); err != nil {
		return fmt.Errorf("failed to delete portal from database: %w", err)
	}

	s.client.log.Info().Str("agent_id", agentID).Msg("Deleted agent data room")
	return nil
}

// SaveAgent implements agents.AgentStore.
// It saves an agent to its own hidden data room.
func (s *AgentStoreAdapter) SaveAgent(ctx context.Context, agent *agents.AgentDefinition) error {
	if err := agent.Validate(); err != nil {
		return err
	}
	if agent.IsPreset {
		return agents.ErrAgentIsPreset
	}

	if err := s.saveAgentToDataRoom(ctx, ToAgentDefinitionContent(agent)); err != nil {
		return err
	}

	s.client.log.Info().Str("agent_id", agent.ID).Str("name", agent.Name).Msg("Saved custom agent to data room")
	return nil
}

// DeleteAgent implements agents.AgentStore.
// It deletes an agent and its hidden data room.
func (s *AgentStoreAdapter) DeleteAgent(ctx context.Context, agentID string) error {
	if agents.IsPreset(agentID) || agents.IsBossAgent(agentID) {
		return agents.ErrAgentIsPreset
	}

	// Check if agent exists first
	content, err := s.loadAgentFromDataRoom(ctx, agentID)
	if err != nil {
		return fmt.Errorf("failed to check agent existence: %w", err)
	}
	if content == nil {
		return agents.ErrAgentNotFound
	}

	// Delete the agent's hidden data room
	if err := s.deleteAgentDataRoom(ctx, agentID); err != nil {
		return err
	}

	s.client.log.Info().Str("agent_id", agentID).Msg("Deleted custom agent and data room")
	return nil
}

// ListModels implements agents.AgentStore.
func (s *AgentStoreAdapter) ListModels(ctx context.Context) ([]agents.ModelInfo, error) {
	models, err := s.client.listAvailableModels(ctx, false)
	if err != nil {
		return nil, err
	}

	result := make([]agents.ModelInfo, 0, len(models))
	for _, m := range models {
		result = append(result, agents.ModelInfo{
			ID:          m.ID,
			Name:        m.Name,
			Provider:    m.Provider,
			Description: m.Description,
		})
	}
	return result, nil
}

// ListAvailableTools implements agents.AgentStore.
func (s *AgentStoreAdapter) ListAvailableTools(_ context.Context) ([]tools.ToolInfo, error) {
	registry := tools.DefaultRegistry()

	var result []tools.ToolInfo
	for _, tool := range registry.All() {
		result = append(result, tools.ToolInfo{
			Name:        tool.Name,
			Description: tool.Description,
			Type:        tool.Type,
			Group:       tool.Group,
			Enabled:     true, // All tools are available, policy determines which are enabled
		})
	}
	return result, nil
}

// Verify interface compliance
var _ agents.AgentStore = (*AgentStoreAdapter)(nil)

// GetAgentByID looks up an agent by ID, returning preset or custom agents.
func (s *AgentStoreAdapter) GetAgentByID(ctx context.Context, agentID string) (*agents.AgentDefinition, error) {
	agentsMap, err := s.LoadAgents(ctx)
	if err != nil {
		return nil, err
	}

	agent, ok := agentsMap[agentID]
	if !ok {
		return nil, agents.ErrAgentNotFound
	}
	return agent, nil
}

// GetAgentForRoom returns the agent assigned to a room.
// Falls back to the Quick Chatter if no specific agent is set.
func (s *AgentStoreAdapter) GetAgentForRoom(ctx context.Context, meta *PortalMetadata) (*agents.AgentDefinition, error) {
	agentID := resolveAgentID(meta)
	if agentID == "" {
		agentID = agents.DefaultAgentID // Default to Beeper AI
	}

	return s.GetAgentByID(ctx, agentID)
}

// CreateExecutorForAgent creates a tools.Executor configured for an agent.
func (s *AgentStoreAdapter) CreateExecutorForAgent(agent *agents.AgentDefinition) *tools.Executor {
	registry := tools.DefaultRegistry()

	// Register boss tools if this is the boss agent
	if agent.ID == "boss" {
		for _, tool := range tools.BossTools() {
			if !registry.Has(tool.Name) {
				registry.Register(tool)
			}
		}
	}

	policy := agents.CreatePolicyFromProfile(agent, registry)
	return tools.NewExecutor(registry, policy)
}

// ToAgentDefinitionContent converts an AgentDefinition to its Matrix event form.
func ToAgentDefinitionContent(agent *agents.AgentDefinition) *AgentDefinitionContent {
	content := &AgentDefinitionContent{
		ID:              agent.ID,
		Name:            agent.Name,
		Description:     agent.Description,
		AvatarURL:       agent.AvatarURL,
		Model:           agent.Model.Primary,
		ModelFallback:   agent.Model.Fallbacks,
		SystemPrompt:    agent.SystemPrompt,
		PromptMode:      string(agent.PromptMode),
		ToolProfile:     string(agent.ToolProfile),
		ToolOverrides:   agent.ToolOverrides,
		ToolAlsoAllow:   agent.ToolAlsoAllow,
		Temperature:     agent.Temperature,
		ReasoningEffort: agent.ReasoningEffort,
		IsPreset:        agent.IsPreset,
		CreatedAt:       agent.CreatedAt,
		UpdatedAt:       agent.UpdatedAt,
	}

	// Include Identity if present
	if agent.Identity != nil {
		content.IdentityName = agent.Identity.Name
		content.IdentityPersona = agent.Identity.Persona
	}

	// Convert memory config
	if agent.Memory != nil {
		content.MemoryConfig = &AgentMemoryConfig{
			Enabled:      agent.Memory.Enabled,
			Sources:      agent.Memory.Sources,
			EnableGlobal: agent.Memory.EnableGlobal,
			MaxResults:   agent.Memory.MaxResults,
			MinScore:     agent.Memory.MinScore,
		}
	}
	if agent.MemorySearch != nil {
		content.MemorySearch = agent.MemorySearch
	}

	return content
}

// FromAgentDefinitionContent converts a Matrix event form to AgentDefinition.
func FromAgentDefinitionContent(content *AgentDefinitionContent) *agents.AgentDefinition {
	def := &agents.AgentDefinition{
		ID:          content.ID,
		Name:        content.Name,
		Description: content.Description,
		AvatarURL:   content.AvatarURL,
		Model: agents.ModelConfig{
			Primary:   content.Model,
			Fallbacks: content.ModelFallback,
		},
		SystemPrompt:    content.SystemPrompt,
		PromptMode:      agents.PromptMode(content.PromptMode),
		ToolProfile:     agents.ToolProfile(content.ToolProfile),
		ToolOverrides:   content.ToolOverrides,
		ToolAlsoAllow:   content.ToolAlsoAllow,
		Temperature:     content.Temperature,
		ReasoningEffort: content.ReasoningEffort,
		IsPreset:        content.IsPreset,
		CreatedAt:       content.CreatedAt,
		UpdatedAt:       content.UpdatedAt,
	}

	// Restore Identity if present
	if content.IdentityName != "" || content.IdentityPersona != "" {
		def.Identity = &agents.Identity{
			Name:    content.IdentityName,
			Persona: content.IdentityPersona,
		}
	}

	// Restore memory config if present
	if content.MemoryConfig != nil {
		def.Memory = &agents.MemoryConfig{
			Enabled:      content.MemoryConfig.Enabled,
			Sources:      content.MemoryConfig.Sources,
			EnableGlobal: content.MemoryConfig.EnableGlobal,
			MaxResults:   content.MemoryConfig.MaxResults,
			MinScore:     content.MemoryConfig.MinScore,
		}
	}
	if content.MemorySearch != nil {
		def.MemorySearch = content.MemorySearch
	}

	return def
}

// BossStoreAdapter implements tools.AgentStoreInterface for boss tool execution.
// This adapter converts between our agent types and the tools package types.
type BossStoreAdapter struct {
	store *AgentStoreAdapter
}

// NewBossStoreAdapter creates a new boss store adapter.
func NewBossStoreAdapter(client *AIClient) *BossStoreAdapter {
	return &BossStoreAdapter{
		store: NewAgentStoreAdapter(client),
	}
}

// LoadAgents implements tools.AgentStoreInterface.
func (b *BossStoreAdapter) LoadAgents(ctx context.Context) (map[string]tools.AgentData, error) {
	agentsMap, err := b.store.LoadAgents(ctx)
	if err != nil {
		return nil, err
	}

	result := make(map[string]tools.AgentData, len(agentsMap))
	for id, agent := range agentsMap {
		result[id] = agentToToolsData(agent)
	}
	return result, nil
}

// SaveAgent implements tools.AgentStoreInterface.
func (b *BossStoreAdapter) SaveAgent(ctx context.Context, agent tools.AgentData) error {
	def := toolsDataToAgent(agent)
	return b.store.SaveAgent(ctx, def)
}

// DeleteAgent implements tools.AgentStoreInterface.
func (b *BossStoreAdapter) DeleteAgent(ctx context.Context, agentID string) error {
	return b.store.DeleteAgent(ctx, agentID)
}

// ListModels implements tools.AgentStoreInterface.
func (b *BossStoreAdapter) ListModels(ctx context.Context) ([]tools.ModelData, error) {
	models, err := b.store.ListModels(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]tools.ModelData, 0, len(models))
	for _, m := range models {
		result = append(result, tools.ModelData{
			ID:          m.ID,
			Name:        m.Name,
			Provider:    m.Provider,
			Description: m.Description,
		})
	}
	return result, nil
}

// ListAvailableTools implements tools.AgentStoreInterface.
func (b *BossStoreAdapter) ListAvailableTools(ctx context.Context) ([]tools.ToolInfo, error) {
	return b.store.ListAvailableTools(ctx)
}

// RunInternalCommand implements tools.AgentStoreInterface.
func (b *BossStoreAdapter) RunInternalCommand(ctx context.Context, roomID string, command string) (string, error) {
	command = strings.TrimSpace(command)
	if command == "" {
		return "", fmt.Errorf("command is required")
	}
	if roomID == "" {
		return "", fmt.Errorf("room_id is required")
	}

	prefix := b.store.client.connector.br.Config.CommandPrefix
	if strings.HasPrefix(command, prefix) {
		command = strings.TrimSpace(strings.TrimPrefix(command, prefix))
	}
	command = strings.TrimSpace(command)
	if command == "" {
		return "", fmt.Errorf("command is empty after trimming prefix")
	}

	proc, ok := b.store.client.connector.br.Commands.(*commands.Processor)
	if !ok {
		return "", fmt.Errorf("command processor not available")
	}

	eventID := id.EventID(fmt.Sprintf("$internal-%s", uuid.NewString()))
	proc.Handle(ctx, id.RoomID(roomID), eventID, b.store.client.UserLogin.User, command, "")
	return "Command dispatched.", nil
}

// CreateRoom implements tools.AgentStoreInterface.
func (b *BossStoreAdapter) CreateRoom(ctx context.Context, room tools.RoomData) (string, error) {
	// Get the agent to verify it exists
	agent, err := b.store.GetAgentByID(ctx, room.AgentID)
	if err != nil {
		return "", fmt.Errorf("agent '%s' not found: %w", room.AgentID, err)
	}

	// Create the portal via createAgentChat
	resp, err := b.store.client.createAgentChat(ctx, agent)
	if err != nil {
		return "", fmt.Errorf("failed to create room: %w", err)
	}

	// Get the portal to apply any overrides
	portal, err := b.store.client.UserLogin.Bridge.GetPortalByKey(ctx, resp.PortalKey)
	if err != nil {
		return "", fmt.Errorf("failed to get created portal: %w", err)
	}

	// Apply custom name and system prompt if provided
	pm := portalMeta(portal)
	originalName := portal.Name
	originalNameSet := portal.NameSet
	originalTitle := pm.Title
	originalTitleGenerated := pm.TitleGenerated
	originalSystemPrompt := pm.SystemPrompt

	if room.Name != "" {
		pm.Title = room.Name
		portal.Name = room.Name
		portal.NameSet = true
		if resp.PortalInfo != nil {
			resp.PortalInfo.Name = &room.Name
		}
	}
	if room.SystemPrompt != "" {
		pm.SystemPrompt = room.SystemPrompt
		// Note: portal.Topic is NOT set to SystemPrompt - they are separate concepts
		// Topic is for display only, SystemPrompt is for LLM context
	}

	// Create the Matrix room
	if err := portal.CreateMatrixRoom(ctx, b.store.client.UserLogin, resp.PortalInfo); err != nil {
		cleanupPortal(ctx, b.store.client, portal, "failed to create Matrix room")
		return "", fmt.Errorf("failed to create Matrix room: %w", err)
	}

	// Send welcome message (excluded from LLM history)
	b.store.client.sendWelcomeMessage(ctx, portal)

	if room.Name != "" {
		if err := b.store.client.setRoomNameNoSave(ctx, portal, room.Name); err != nil {
			b.store.client.log.Warn().Err(err).Msg("Failed to set Matrix room name")
			portal.Name = originalName
			portal.NameSet = originalNameSet
			pm.Title = originalTitle
			pm.TitleGenerated = originalTitleGenerated
		}
	}
	if room.SystemPrompt != "" {
		if err := b.store.client.setRoomSystemPromptNoSave(ctx, portal, room.SystemPrompt); err != nil {
			b.store.client.log.Warn().Err(err).Msg("Failed to set room system prompt")
			pm.SystemPrompt = originalSystemPrompt
		}
	}

	if err := portal.Save(ctx); err != nil {
		return "", fmt.Errorf("failed to save room overrides: %w", err)
	}

	return string(portal.PortalKey.ID), nil
}

// ModifyRoom implements tools.AgentStoreInterface.
func (b *BossStoreAdapter) ModifyRoom(ctx context.Context, roomID string, updates tools.RoomData) error {
	// Find the portal by listing all and matching ID
	portals, err := b.store.client.listAllChatPortals(ctx)
	if err != nil {
		return fmt.Errorf("failed to list portals: %w", err)
	}

	var portal *bridgev2.Portal
	for _, p := range portals {
		if string(p.PortalKey.ID) == roomID {
			portal = p
			break
		}
	}
	if portal == nil {
		return fmt.Errorf("room '%s' not found", roomID)
	}

	pm := portalMeta(portal)

	// Apply updates
	if updates.Name != "" {
		portal.Name = updates.Name
		pm.Title = updates.Name
		portal.NameSet = true
	}
	if updates.AgentID != "" {
		// Verify agent exists
		agent, err := b.store.GetAgentByID(ctx, updates.AgentID)
		if err != nil {
			return fmt.Errorf("agent '%s' not found: %w", updates.AgentID, err)
		}
		pm.AgentID = agent.ID
		pm.DefaultAgentID = agent.ID
		modelID := b.store.client.effectiveModel(pm)
		portal.OtherUserID = agentModelUserID(agent.ID, modelID)
		b.store.client.ensureAgentModelGhostDisplayName(ctx, agent.ID, modelID, agent.Name)
	}
	if updates.SystemPrompt != "" {
		pm.SystemPrompt = updates.SystemPrompt
		// Note: portal.Topic is NOT set to SystemPrompt - they are separate concepts
	}

	if updates.Name != "" && portal.MXID != "" {
		if err := b.store.client.setRoomName(ctx, portal, updates.Name); err != nil {
			b.store.client.log.Warn().Err(err).Msg("Failed to set Matrix room name")
		}
	}
	if updates.SystemPrompt != "" && portal.MXID != "" {
		if err := b.store.client.setRoomSystemPrompt(ctx, portal, updates.SystemPrompt); err != nil {
			b.store.client.log.Warn().Err(err).Msg("Failed to set room system prompt")
		}
	}

	return portal.Save(ctx)
}

// ListRooms implements tools.AgentStoreInterface.
func (b *BossStoreAdapter) ListRooms(ctx context.Context) ([]tools.RoomData, error) {
	portals, err := b.store.client.listAllChatPortals(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list rooms: %w", err)
	}

	var rooms []tools.RoomData
	for _, portal := range portals {
		pm := portalMeta(portal)
		name := portal.Name
		if name == "" {
			name = pm.Title
		}
		rooms = append(rooms, tools.RoomData{
			ID:      string(portal.PortalKey.ID),
			Name:    name,
			AgentID: pm.AgentID,
		})
	}

	return rooms, nil
}

// GetRoomHistory returns message history for a room.
func (b *BossStoreAdapter) GetRoomHistory(ctx context.Context, roomID string, limit int) ([]tools.MessageData, error) {
	// Parse room ID
	roomIDParsed := id.RoomID(roomID)

	// Find the portal for this room
	allPortals, err := b.store.client.UserLogin.Bridge.DB.Portal.GetAll(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list portals: %w", err)
	}

	var portalKey networkid.PortalKey
	found := false
	for _, portal := range allPortals {
		if portal.MXID == roomIDParsed {
			portalKey = portal.PortalKey
			found = true
			break
		}
	}

	if !found {
		return nil, fmt.Errorf("room not found: %s", roomID)
	}

	// Get messages from database
	messages, err := b.store.client.UserLogin.Bridge.DB.Message.GetLastNInPortal(ctx, portalKey, limit)
	if err != nil {
		return nil, fmt.Errorf("failed to get messages: %w", err)
	}

	// Convert to tools.MessageData
	var result []tools.MessageData
	for _, msg := range messages {
		msgMeta, ok := msg.Metadata.(*MessageMetadata)
		if !ok || msgMeta == nil {
			continue
		}

		result = append(result, tools.MessageData{
			ID:        msg.MXID.String(),
			Role:      msgMeta.Role,
			Content:   msgMeta.Body,
			Timestamp: msg.Timestamp.Unix(),
		})
	}

	return result, nil
}

// SendToRoom sends a message to a room.
func (b *BossStoreAdapter) SendToRoom(ctx context.Context, roomID string, message string) error {
	// Get the portal for this room
	roomIDParsed := id.RoomID(roomID)

	// Get the bot to send the message
	bot := b.store.client.UserLogin.Bridge.Bot

	// Send the message as the bot
	rendered := format.RenderMarkdown(message, true, true)
	eventContent := &event.Content{
		Raw: map[string]any{
			"msgtype":        event.MsgText,
			"body":           rendered.Body,
			"format":         rendered.Format,
			"formatted_body": rendered.FormattedBody,
		},
	}

	_, err := bot.SendMessage(ctx, roomIDParsed, event.EventMessage, eventContent, nil)
	return err
}

// Verify interface compliance
var _ tools.AgentStoreInterface = (*BossStoreAdapter)(nil)

// agentToToolsData converts an AgentDefinition to tools.AgentData.
func agentToToolsData(agent *agents.AgentDefinition) tools.AgentData {
	return tools.AgentData{
		ID:            agent.ID,
		Name:          agent.Name,
		Description:   agent.Description,
		Model:         agent.Model.Primary,
		SystemPrompt:  agent.SystemPrompt,
		ToolProfile:   string(agent.ToolProfile),
		ToolOverrides: agent.ToolOverrides,
		ToolAlsoAllow: agent.ToolAlsoAllow,
		Temperature:   agent.Temperature,
		IsPreset:      agent.IsPreset,
		CreatedAt:     agent.CreatedAt,
		UpdatedAt:     agent.UpdatedAt,
	}
}

// toolsDataToAgent converts tools.AgentData to an AgentDefinition.
func toolsDataToAgent(data tools.AgentData) *agents.AgentDefinition {
	return &agents.AgentDefinition{
		ID:          data.ID,
		Name:        data.Name,
		Description: data.Description,
		Model: agents.ModelConfig{
			Primary: data.Model,
		},
		SystemPrompt:  data.SystemPrompt,
		ToolProfile:   agents.ToolProfile(data.ToolProfile),
		ToolOverrides: data.ToolOverrides,
		ToolAlsoAllow: data.ToolAlsoAllow,
		Temperature:   data.Temperature,
		IsPreset:      data.IsPreset,
		CreatedAt:     data.CreatedAt,
		UpdatedAt:     data.UpdatedAt,
	}
}
